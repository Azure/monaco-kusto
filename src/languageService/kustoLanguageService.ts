/// <reference path="../../node_modules/@kusto/language-service/Kusto.JavaScript.Client.d.ts" />
/// <reference path="../../node_modules/@kusto/language-service-next/Kusto.Language.Bridge.d.ts" />
/// <reference path="../typings/refs.d.ts" />
import * as s from './schema';

// polyfill string endsWith
if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (search, this_len) {
        if (this_len === undefined || this_len > this.length) {
            this_len = this.length;
        }
        return this.substring(this_len - search.length, this_len) === search;
    };
}

// If we're running in a web worker - which doesn't share global context with the main thread -
// we need to manually load dependencies that are not explicit- meaning our non-module dependencies
// generated by Bridge.Net
if (typeof document == 'undefined') {
    // monaco will run the workder from vs/base/worker so the relative path needs to be from there (hence going up 2 dirs)
    importScripts('../../language/kusto/bridge.min.js');
    importScripts('../../language/kusto/kusto.javascript.client.min.js');
    importScripts('../../language/kusto/Kusto.Language.Bridge.min.js');
}

import Promise = monaco.Promise;
import * as ls from 'vscode-languageserver-types';
import { FoldingRange } from 'vscode-languageserver-protocol-foldingprovider';
import * as XRegExp from 'xregexp';
import k = Kusto.Data.IntelliSense;
import k2 = Kusto.Language.Editor;
import sym = Kusto.Language.Symbols;
import GlobalState = Kusto.Language.GlobalState;

import { Database, getCslTypeNameFromClrType, getEntityDataTypeFromCslType } from './schema';
import { RenderOptions, VisualizationType, RenderOptionKeys, RenderInfo, LegendVisibility } from './renderInfo';

let List = System.Collections.Generic.List$1;

function assertNever(x: never): never {
    throw new Error('Unexpected object: ' + x);
}

class ParseProperties {
    constructor(
        private version: number,
        private uri: string,
        private rulesProvider?: k.IntelliSenseRulesProviderBase,
        private parseMode?: k.ParseMode
    ) {}

    isParseNeeded(document: ls.TextDocument, rulesProvider?: k.IntelliSenseRulesProviderBase, parseMode?: k.ParseMode) {
        if (
            document.uri === this.uri &&
            (!rulesProvider || rulesProvider === this.rulesProvider) &&
            document.version <= this.version &&
            parseMode &&
            parseMode <= this.parseMode
        ) {
            return false;
        }

        return true;
    }
}

export enum TokenKind {
    TableToken = 2,
    TableColumnToken = 4,
    OperatorToken = 8, // where, projectm, ...
    SubOperatorToken = 16, // has, contains, ...
    CalculatedColumnToken = 32,
    StringLiteralToken = 64,
    FunctionNameToken = 128,
    UnknownToken = 256,
    CommentToken = 512,
    PlainTextToken = 1024,
    DataTypeToken = 2048,
    ControlCommandToken = 4096,
    CommandPartToken = 8192,
    QueryParametersToken = 16384,
    CslCommandToken = 32768,
    LetVariablesToken = 65536,
    PluginToken = 131072,
    BracketRangeToken = 262144,
    ClientDirectiveToken = 524288,
}

/**
 * colorization data for specific line range.
 */
export interface ColorizationRange {
    classifications: k2.ClassifiedRange[];
    absoluteStart: number;
    absoluteEnd: number;
}

export interface LanguageService {
    doComplete(document: ls.TextDocument, position: ls.Position): Promise<ls.CompletionList>;
    doRangeFormat(document: ls.TextDocument, range: ls.Range): Promise<ls.TextEdit[]>;
    doDocumentformat(document: ls.TextDocument): Promise<ls.TextEdit[]>;
    doCurrentCommandFormat(document: ls.TextDocument, caretPosition: ls.Position): Promise<ls.TextEdit[]>;
    doFolding(document: ls.TextDocument): Promise<FoldingRange[]>;
    doValidation(document: ls.TextDocument, intervals: { start: number; end: number }[]): Promise<ls.Diagnostic[]>;
    doColorization(
        document: ls.TextDocument,
        intervals: { start: number; end: number }[]
    ): Promise<ColorizationRange[]>;
    doRename(doucment: ls.TextDocument, position: ls.Position, newName: string): Promise<ls.WorkspaceEdit | undefined>;
    doHover(document: ls.TextDocument, position: ls.Position): Promise<ls.Hover | undefined>;
    setParameters(parameters: s.ScalarParameter[]);
    setSchema(schema: s.Schema): Promise<void>;
    setSchemaFromShowSchema(
        schema: s.showSchema.Result,
        clusterConnectionString: string,
        databaseInContextName: string,
        globalParameters?: s.ScalarParameter[]
    ): Promise<void>;
    normalizeSchema(
        schema: s.showSchema.Result,
        clusterConnectionString: string,
        databaseInContextName: string
    ): Promise<s.EngineSchema>;
    getSchema(): Promise<s.Schema>;
    getCommandInContext(document: ls.TextDocument, cursorOffset: number): Promise<string>;
    getCommandAndLocationInContext(
        document: ls.TextDocument,
        cursorOffset: number
    ): Promise<{ text: string; location: ls.Location } | null>;
    getCommandsInDocument(
        document: ls.TextDocument
    ): Promise<{ absoluteStart: number; absoluteEnd: number; text: string }[]>;
    configure(languageSettings: LanguageSettings): void;
    getClientDirective(text: string): Promise<{ isClientDirective: boolean; directiveWithoutLeadingComments: string }>;
    getAdminCommand(text: string): Promise<{ isAdminCommand: boolean; adminCommandWithoutLeadingComments: string }>;
    findDefinition(document: ls.TextDocument, position: ls.Position): Promise<ls.Location[]>;
    findReferences(document: ls.TextDocument, position: ls.Position): Promise<ls.Location[]>;
    getQueryParams(document: ls.TextDocument, cursorOffset: number): Promise<{ name: string; type: string }[]>;
    getGlobalParams(document: ls.TextDocument): Promise<{ name: string; type: string }[]>;
    getReferencedGlobalParams(document: ls.TextDocument, offset: number): Promise<{ name: string; type: string }[]>;
    getRenderInfo(document: ls.TextDocument, cursorOffset: number): Promise<RenderInfo | undefined>;
}

export interface LanguageSettings {
    includeControlCommands?: boolean;
    newlineAfterPipe?: boolean;
    useIntellisenseV2: boolean;
    useSemanticColorization?: boolean;
    useTokenColorization?: boolean;
    disabledCompletionItems?: string[];
    onDidProvideCompletionItems?: monaco.languages.kusto.OnDidProvideCompletionItems;
}

export type CmSchema = {
    accounts: k.KustoIntelliSenseAccountEntity[];
    services: k.KustoIntelliSenseServiceEntity[];
    connectionString: string;
};

/**
 * Kusto Language service translates the kusto object model (transpiled from C# by Bridge.Net)
 * to the vscode language server types, which are used by vscode lanugage extensions.
 * This should make things easier in the future to provide a vscode extension based on this translation layer.
 *
 * Further translations, if needed, to support specific editors (Atom, sublime, Etc)
 * should be done on top of this API, since it is (at least meant to be) a standard that is supported by multiple editors.
 *
 * Note1:  Currenlty monaco isn't using this object model so further translation will be necessary on calling modules.
 *
 * Note2: This file is responsible for interacting with the kusto object model and exposing Microsoft language service types.
 * An exception to that rule is tokenization (and syntax highlighting which depends on it) -
 * since it's not currently part of the Microosft language service protocol. Thus tokenize() _does_ 'leak' kusto types to the callers.
 */
class KustoLanguageService implements LanguageService {
    private _kustoJsSchema: k.KustoIntelliSenseQuerySchema | CmSchema | undefined;
    private _kustoJsSchemaV2: GlobalState;
    private _languageSettings: LanguageSettings;
    private _schema: s.Schema;
    private _schemaCache: {
        [cluster: string]: {
            [dbName: string]: { database: s.Database; symbol: sym.DatabaseSymbol; includesFunctions: boolean };
        };
    };
    private _parser: k.CslCommandParser;
    private _script: k2.CodeScript;
    private _parsePropertiesV1: ParseProperties;
    private _parsePropertiesV2: ParseProperties;
    private _rulesProvider:
        | k.CslIntelliSenseRulesProvider
        | k.CslQueryIntelliSenseRulesProvider
        | k.DataManagerIntelliSenseRulesProvider
        | k.ClusterManagerIntelliSenseRulesProvider;
    private _newlineAppendPipePolicy: Kusto.Data.IntelliSense.ApplyPolicy;
    private _toOptionKind: { [completionKind in k2.CompletionKind]: k.OptionKind } = {
        [k2.CompletionKind.AggregateFunction]: k.OptionKind.FunctionAggregation,
        [k2.CompletionKind.BuiltInFunction]: k.OptionKind.FunctionServerSide,
        [k2.CompletionKind.Cluster]: k.OptionKind.Database,
        [k2.CompletionKind.Column]: k.OptionKind.Column,
        [k2.CompletionKind.CommandPrefix]: k.OptionKind.None,
        [k2.CompletionKind.Database]: k.OptionKind.Database,
        [k2.CompletionKind.DatabaseFunction]: k.OptionKind.FunctionServerSide,
        [k2.CompletionKind.Example]: k.OptionKind.None,
        [k2.CompletionKind.Identifier]: k.OptionKind.None,
        [k2.CompletionKind.Keyword]: k.OptionKind.None,
        [k2.CompletionKind.LocalFunction]: k.OptionKind.FunctionLocal,
        [k2.CompletionKind.MaterialiedView]: k.OptionKind.MaterializedView,
        [k2.CompletionKind.Parameter]: k.OptionKind.Parameter,
        [k2.CompletionKind.Punctuation]: k.OptionKind.None,
        [k2.CompletionKind.QueryPrefix]: k.OptionKind.Operator,
        [k2.CompletionKind.RenderChart]: k.OptionKind.Operator,
        [k2.CompletionKind.ScalarInfix]: k.OptionKind.None,
        [k2.CompletionKind.ScalarPrefix]: k.OptionKind.None,
        [k2.CompletionKind.ScalarType]: k.OptionKind.DataType,
        [k2.CompletionKind.Syntax]: k.OptionKind.None,
        [k2.CompletionKind.Table]: k.OptionKind.Table,
        [k2.CompletionKind.TabularPrefix]: k.OptionKind.None,
        [k2.CompletionKind.TabularSuffix]: k.OptionKind.None,
        [k2.CompletionKind.Unknown]: k.OptionKind.None,
        [k2.CompletionKind.Variable]: k.OptionKind.Parameter,
    };

    constructor(schema: s.EngineSchema, languageSettings: LanguageSettings) {
        this._schemaCache = {};
        this._kustoJsSchema = KustoLanguageService.convertToKustoJsSchema(schema);
        this._kustoJsSchemaV2 = this.convertToKustoJsSchemaV2(schema);
        this._schema = schema;

        this.configure(languageSettings);
        this._newlineAppendPipePolicy = new Kusto.Data.IntelliSense.ApplyPolicy();
        this._newlineAppendPipePolicy.Text = '\n| ';
    }

    configure(languageSettings: LanguageSettings) {
        this._languageSettings = languageSettings;

        // Since we're still reverting to V1 intellisense for control commands, we need to update the rules provider
        // (which is a notion of V1 intellisense).
        this.createRulesProvider(this._kustoJsSchema, this._schema.clusterType);
    }

    doComplete(document: ls.TextDocument, position: ls.Position): Promise<ls.CompletionList> {
        return this.isIntellisenseV2() ? this.doCompleteV2(document, position) : this.doCompleteV1(document, position);
    }

    private disabledCompletionItemsV2: { [value: string]: k2.CompletionKind } = {
        // render charts
        ladderchart: k2.CompletionKind.RenderChart,
        pivotchart: k2.CompletionKind.RenderChart,
        timeline: k2.CompletionKind.RenderChart,
        timepivot: k2.CompletionKind.RenderChart,
        '3Dchart': k2.CompletionKind.RenderChart,
        list: k2.CompletionKind.RenderChart,
    };

    doCompleteV2(document: ls.TextDocument, position: ls.Position): Promise<ls.CompletionList> {
        const script = this.parseDocumentV2(document);
        const cursorOffset = document.offsetAt(position);
        let currentcommand = this.getCurrentCommandV2(script, cursorOffset);

        const completionItems = currentcommand.Service.GetCompletionItems(cursorOffset);

        let disabledItems = this.disabledCompletionItemsV2;
        if (this._languageSettings.disabledCompletionItems) {
            this._languageSettings.disabledCompletionItems.map((item) => {
                // logic will treat unknown as a '*' wildcard, meaning that if the key is in the object
                // the completion item will be suppressed.
                disabledItems[item] = k2.CompletionKind.Unknown;
            });
        }

        let items: ls.CompletionItem[] = this.toArray<k2.CompletionItem>(completionItems.Items)
            .filter(
                (item) =>
                    !(
                        item &&
                        item.MatchText &&
                        disabledItems[item.MatchText] !== undefined &&
                        (disabledItems[item.MatchText] === k2.CompletionKind.Unknown ||
                            disabledItems[item.MatchText] === item.Kind)
                    )
            )
            .map((kItem, i) => {
                const v1CompletionOption = new k.CompletionOption(
                    this._toOptionKind[kItem.Kind] || k.OptionKind.None,
                    kItem.DisplayText
                );
                const helpTopic: k.CslTopicDocumentation = this.getTopic(v1CompletionOption);
                // If we have AfterText it means that the cursor should no be placed at end of suggested text.
                // In that case we switch to snippet format and represent the point where the cursor should be as
                // as '\$0'
                const { textToInsert, format } =
                    kItem.AfterText && kItem.AfterText.length > 0
                        ? {
                              textToInsert: kItem.EditText + '$0' + kItem.AfterText,
                              format: ls.InsertTextFormat.Snippet,
                          }
                        : {
                              textToInsert: kItem.EditText,
                              format: ls.InsertTextFormat.PlainText,
                          };

                const lsItem = ls.CompletionItem.create(kItem.DisplayText);

                const startPosition = document.positionAt(completionItems.EditStart);
                const endPosition = document.positionAt(completionItems.EditStart + completionItems.EditLength);
                lsItem.textEdit = ls.TextEdit.replace(ls.Range.create(startPosition, endPosition), textToInsert);
                lsItem.sortText = this.getSortText(i + 1);
                lsItem.kind = this.kustoKindToLsKindV2(kItem.Kind);
                lsItem.insertTextFormat = format;
                lsItem.detail = helpTopic ? helpTopic.ShortDescription : undefined;
                lsItem.documentation = helpTopic
                    ? { value: helpTopic.LongDescription, kind: ls.MarkupKind.Markdown }
                    : undefined;
                return lsItem;
            });

        return Promise.as(ls.CompletionList.create(items));
    }

    private isIntellisenseV2 = () =>
        this._languageSettings.useIntellisenseV2 && this._schema && this._schema.clusterType === 'Engine';

    /**
     * when trying to get a topic we need the funtion name (abs, tolower, ETC).
     * The problem is that the 'Value' string also contains the  arguments (e.g abs(nubmer)), which means that we are
     * not able to correlate the option with its documentation.
     * This piece of code tries to strip this hwne getting topic.
     * @param completionOption the Completion option
     */
    private getTopic(completionOption: k.CompletionOption): k.CslTopicDocumentation {
        if (
            completionOption.Kind == k.OptionKind.FunctionScalar ||
            completionOption.Kind == k.OptionKind.FunctionAggregation
        ) {
            // from a value like 'abs(number)' remove the '(number)' so that only 'abs' will remain
            const indexOfParen = completionOption.Value.indexOf('(');
            if (indexOfParen >= 0) {
                completionOption = new k.CompletionOption(
                    completionOption.Kind,
                    completionOption.Value.substring(0, indexOfParen)
                );
            }
        }

        return k.CslDocumentation.Instance.GetTopic(completionOption);
    }

    private disabledCompletionItemsV1: { [value: string]: k.OptionKind } = {
        capacity: k.OptionKind.Policy,
        callout: k.OptionKind.Policy,
        encoding: k.OptionKind.Policy,
        batching: k.OptionKind.Policy,
        querythrottling: k.OptionKind.Policy,
        merge: k.OptionKind.Policy,
        querylimit: k.OptionKind.Policy,
        rowstore: k.OptionKind.Policy,
        streamingingestion: k.OptionKind.Policy,
        restricted_view_access: k.OptionKind.Policy,
        sharding: k.OptionKind.Policy,
        'restricted-viewers': k.OptionKind.Policy,
        attach: k.OptionKind.Command,
        purge: k.OptionKind.Command,
    };

    doCompleteV1(document: ls.TextDocument, position: ls.Position): Promise<ls.CompletionList> {
        // TODO: fix typing in CslCommandParser to allow rulesProvider to be query only.
        let caretAbsolutePosition = document.offsetAt(position);

        // find out what's the current command to only parse this one.
        this.parseDocumentV1(document, k.ParseMode.CommandTokensOnly);
        let currentCommand = this.getCurrentCommand(document, caretAbsolutePosition);

        let commandTextUntilCursor = '';
        if (currentCommand) {
            const commandStartOffset = currentCommand.AbsoluteStart;
            this.parseTextV1(currentCommand.Text, k.ParseMode.TokenizeAllText);
            const caretRelativePosition = caretAbsolutePosition - currentCommand.AbsoluteStart;
            commandTextUntilCursor = currentCommand.Text.substring(
                currentCommand.CslExpressionStartPosition,
                caretRelativePosition
            );
        }

        let commandTextWithoutLastWord = this.getCommandWithoutLastWord(commandTextUntilCursor);

        let context = this._rulesProvider.AnalyzeCommand$1(commandTextUntilCursor, currentCommand).Context;

        let result = { v: null };
        this._rulesProvider.TryMatchAnyRule(commandTextWithoutLastWord, result);
        let rule: k.IntelliSenseRule = result.v;

        if (rule) {
            const completionOptions = this.toArray(rule.GetCompletionOptions(context));

            // TODO once AppendPipePolicy becomes a public static member of ApplyPolicy in our c# code, and bridge.Net transplies this,
            //  remove the 'as any' part..
            // Also = DefaultApplyPolicy is internal in c# code, so not exposed in d.ts, so we cast it to any.
            if (
                this._languageSettings.newlineAfterPipe &&
                (rule as any).DefaultAfterApplyPolicy === (Kusto.Data.IntelliSense.ApplyPolicy as any).AppendPipePolicy
            ) {
                (rule as any).DefaultAfterApplyPolicy = this._newlineAppendPipePolicy;
            }

            let options: ls.CompletionItem[] = completionOptions
                .filter(
                    (option) =>
                        !(option && option.Value && this.disabledCompletionItemsV1[option.Value] === option.Kind)
                )
                .map((option: k.CompletionOption, ordinal: number) => {
                    const { insertText, insertTextFormat } = this.getTextToInsert(rule, option);
                    const helpTopic: k.CslTopicDocumentation = k.CslDocumentation.Instance.GetTopic(option);
                    const item = ls.CompletionItem.create(option.Value);
                    item.kind = this.kustoKindToLsKind(option.Kind);
                    item.insertText = insertText;
                    item.insertTextFormat = insertTextFormat;
                    item.sortText = this.getSortText(ordinal + 1);
                    item.detail = helpTopic ? helpTopic.ShortDescription : undefined;
                    item.documentation = helpTopic
                        ? { value: helpTopic.LongDescription, kind: ls.MarkupKind.Markdown }
                        : undefined;
                    return item;
                });

            return Promise.as(ls.CompletionList.create(options));
        }

        return Promise.as(ls.CompletionList.create([]));
    }

    doRangeFormat(document: ls.TextDocument, range: ls.Range): Promise<ls.TextEdit[]> {
        const rangeStartOffset: number = document.offsetAt(range.start);
        const rangeEndOffset: number = document.offsetAt(range.end);
        const commands = this.getCommandsInDocument(document).then((commands) => {
            const commandsInRange = commands
                .map((command) => {
                    // Chose only selected text from command.
                    const commandSelectionStart =
                        Math.max(rangeStartOffset, command.absoluteStart) - command.absoluteStart;
                    const commandSelectionEnd = Math.min(rangeEndOffset, command.absoluteEnd) - command.absoluteStart;

                    command.text =
                        commandSelectionStart > commandSelectionEnd
                            ? ''
                            : command.text.substring(commandSelectionStart, commandSelectionEnd);

                    return command;
                })
                .filter((command) => command.text.trim() != '');

            const formattedCommands: string[] = commandsInRange.map((command) =>
                Kusto.Data.Common.CslQueryParser.PrettifyQuery(command.text, '')
            );
            const formattedText: string = formattedCommands.join('\r\n\r\n');

            return [ls.TextEdit.replace(range, formattedText)];
        });

        return commands;
    }

    doDocumentformat(document: ls.TextDocument): Promise<ls.TextEdit[]> {
        const commands = this.getCommandsInDocument(document).then((commands) => {
            const formattedCommands = commands.map((command) =>
                Kusto.Data.Common.CslQueryParser.PrettifyQuery(command.text, '')
            );
            const formattedDocument = formattedCommands.join('\r\n\r\n');

            const startPos = document.positionAt(0);
            const endPos = document.positionAt(document.getText().length);
            const fullDocRange = ls.Range.create(startPos, endPos);
            return [ls.TextEdit.replace(fullDocRange, formattedDocument)];
        });

        return commands;
    }

    doCurrentCommandFormat(document: ls.TextDocument, caretPosition: ls.Position): Promise<ls.TextEdit[]> {
        const command: k.CslCommand = this.getCurrentCommand(document, document.offsetAt(caretPosition));
        const start = document.positionAt(command.AbsoluteStart);
        const end = document.positionAt(command.AbsoluteEnd);
        const range = ls.Range.create(start, end);
        return this.doRangeFormat(document, range);
    }

    doFolding(document: ls.TextDocument): Promise<FoldingRange[]> {
        if (!document) {
            return Promise.as([]);
        }

        return this.getCommandsInDocument(document).then((commands) => {
            return commands.map(
                (command): FoldingRange => {
                    // don't count the last empty line as part of the folded range (cnosider linux, mac, pc newlines)
                    if (command.text.endsWith('\r\n')) {
                        command.absoluteEnd -= 2;
                    } else if (command.text.endsWith('\r') || command.text.endsWith('\n')) {
                        --command.absoluteEnd;
                    }

                    const startPosition = document.positionAt(command.absoluteStart);

                    const endPosition = document.positionAt(command.absoluteEnd);
                    return {
                        startLine: startPosition.line,
                        startColumn: startPosition.character,
                        endLine: endPosition.line,
                        endColumn: endPosition.character,
                    };
                }
            );
        });
    }

    doValidation(
        document: ls.TextDocument,
        changeIntervals: { start: number; end: number }[]
    ): Promise<ls.Diagnostic[]> {
        // didn't implement validation for v1.
        if (!this.isIntellisenseV2()) {
            return Promise.as([]);
        }

        const script = this.parseDocumentV2(document);
        let blocks = this.toArray<k2.CodeBlock>(script.Blocks);
        if (changeIntervals.length > 0) {
            blocks = this.getAffectedBlocks(blocks, changeIntervals);
        }

        const diagnostics = blocks
            .map((block) => {
                const diagnostics = this.toArray<Kusto.Language.Diagnostic>(block.Service.GetDiagnostics());
                if (diagnostics) {
                    return diagnostics;
                }

                return [];
            })
            .reduce((prev, curr) => prev.concat(curr), []);

        const lsDiagnostics = this.toLsDiagnostics(diagnostics, document);

        return Promise.as(lsDiagnostics);
    }

    private toLsDiagnostics(diagnostics: Kusto.Language.Diagnostic[], document: ls.TextDocument) {
        return diagnostics
            .filter((diag) => diag.HasLocation)
            .map(
                (diag): ls.Diagnostic => {
                    const start = document.positionAt(diag.Start);
                    const end = document.positionAt(diag.Start + diag.Length);
                    const range = ls.Range.create(start, end);
                    return ls.Diagnostic.create(range, diag.Message, ls.DiagnosticSeverity.Error);
                }
            );
    }

    /**
     * Colorize one or more kusto blocks (a.k.a commands), or just the entire document.
     * Supports multi-cursor editing (colorizes blocks on multiple changes).
     * @param document The document to colorize
     * @param changeIntervals an array containing 0 or more changed intervals. if the array is empty - just colorize the entire row.
     * if the array contains a single change - just color the kusto blocks that wraps this change. If multiple changes are provided,
     * colorize all blocks that intersect these changes.
     * The code will try to only parse once if this is the same command.
     */
    doColorization(
        document: ls.TextDocument,
        changeIntervals: { start: number; end: number }[]
    ): Promise<ColorizationRange[]> {
        if (!this._languageSettings.useSemanticColorization) {
            return Promise.as([]);
        }

        // V1 intellisense
        if (!this.isIntellisenseV2()) {
            // Handle specific ranges changes (and not the whole doc)
            if (changeIntervals.length > 0) {
                this.parseDocumentV1(document, k.ParseMode.CommandTokensOnly);

                const affectedCommands = this.toArray(this._parser.Results).filter((command) =>
                    // a command is affected if it intersects at least on of changed ranges.
                    command // command can be null. we're filtering all nulls in the array.
                        ? changeIntervals.some(
                              ({ start: changeStart, end: changeEnd }) =>
                                  // both intervals intersect if either the start or the end of interval A is inside interval B.
                                  // If we deleted something at the end of a command, the interval will not intersect the current command.
                                  // so we also want consider affected commands commands the end where the interval begins.
                                  // hence the + 1.
                                  (command.AbsoluteStart >= changeStart && command.AbsoluteStart <= changeEnd) ||
                                  (changeStart >= command.AbsoluteStart && changeStart <= command.AbsoluteEnd + 1)
                          )
                        : false
                );

                // We're not on any command so don't return any classifications.
                // this can happen if we're at the and of the file and deleting empty rows (for example).
                if (!affectedCommands || affectedCommands.length === 0) {
                    return Promise.as([
                        {
                            classifications: [],
                            absoluteStart: changeIntervals[0].start,
                            absoluteEnd: changeIntervals[0].end,
                        },
                    ]);
                }

                return Promise.as(
                    affectedCommands.map((command) => {
                        this.parseTextV1(command.Text, k.ParseMode.TokenizeAllText);
                        const classifications = this.getClassificationsFromParseResult(command.AbsoluteStart);
                        return {
                            classifications,
                            absoluteStart: command.AbsoluteStart,
                            absoluteEnd: command.AbsoluteEnd,
                        };
                    })
                );
            }

            // Entire document requested
            this.parseDocumentV1(document, k.ParseMode.TokenizeAllText);
            const classifications = this.getClassificationsFromParseResult();
            return Promise.as([{ classifications, absoluteStart: 0, absoluteEnd: document.getText().length }]);
        }

        // V2 intellisense
        const script = this.parseDocumentV2(document);
        if (changeIntervals.length > 0) {
            const blocks = this.toArray<k2.CodeBlock>(script.Blocks);
            const affectedBlocks = this.getAffectedBlocks(blocks, changeIntervals);

            return Promise.as(
                affectedBlocks.map((block) => ({
                    classifications: this.toArray<k2.ClassifiedRange>(
                        block.Service.GetClassifications(block.Start, block.End).Classifications
                    ),
                    absoluteStart: block.Start,
                    absoluteEnd: block.End,
                }))
            );
        }

        // Entire document requested
        const blocks = this.toArray<k2.CodeBlock>(script.Blocks);
        const classifications = blocks
            .map((block) => {
                return this.toArray<k2.ClassifiedRange>(
                    block.Service.GetClassifications(block.Start, block.Length).Classifications
                );
            })
            .reduce((prev, curr) => prev.concat(curr), []);

        return Promise.as([{ classifications, absoluteStart: 0, absoluteEnd: document.getText().length }]);
    }

    private getAffectedBlocks(blocks: k2.CodeBlock[], changeIntervals: { start: number; end: number }[]) {
        return blocks.filter((block) =>
            // a command is affected if it intersects at least on of changed ranges.
            block // command can be null. we're filtering all nulls in the array.
                ? changeIntervals.some(
                      ({ start: changeStart, end: changeEnd }) =>
                          // both intervals intersect if either the start or the end of interval A is inside interval B.
                          (block.Start >= changeStart && block.Start <= changeEnd) ||
                          (changeStart >= block.Start && changeStart <= block.End + 1)
                  )
                : false
        );
    }

    setSchema(schema: s.Schema): Promise<void> {
        this._schema = schema;
        if (this._languageSettings.useIntellisenseV2) {
            let kustoJsSchemaV2: GlobalState =
                schema && schema.clusterType === 'Engine' ? this.convertToKustoJsSchemaV2(schema) : null;

            this._kustoJsSchemaV2 = kustoJsSchemaV2;
            this._script = undefined;
            this._parsePropertiesV2 = undefined;
        }

        // since V2 doesn't support control commands, we're initializing V1 intellisense for both cases and we'll going to use V1 intellisense for contorl commands.
        return new Promise((resolve, reject) => {
            const kustoJsSchema = schema ? KustoLanguageService.convertToKustoJsSchema(schema) : undefined;
            this._kustoJsSchema = kustoJsSchema;
            this.createRulesProvider(kustoJsSchema, schema.clusterType);
            resolve(undefined);
        });
    }

    setParameters(parameters: s.ScalarParameter[]): Promise<void> {
        if (!this._languageSettings.useIntellisenseV2 || this._schema.clusterType !== 'Engine') {
            throw new Error('setParameters requires intellisense V2 and Engine cluster');
        }

        this._schema.globalParameters = parameters;
        const symbols = parameters.map((param) => KustoLanguageService.createParameterSymbol(param));
        this._kustoJsSchemaV2 = this._kustoJsSchemaV2.WithParameters(symbols);

        return Promise.as(undefined);
    }

    /**
     * A combination of normalizeSchema and setSchema
     * @param schema schema json as received from .show schema as json
     * @param clusterConnectionString cluster connection string
     * @param databaseInContextName name of database in context
     */
    setSchemaFromShowSchema(
        schema: s.showSchema.Result,
        clusterConnectionString: string,
        databaseInContextName: string,
        globalParameters: s.ScalarParameter[]
    ): Promise<void> {
        return this.normalizeSchema(schema, clusterConnectionString, databaseInContextName).then((normalized) =>
            this.setSchema({ ...normalized, globalParameters })
        );
    }

    /**
     * Converts the result of .show schema as json to a normalized schema used by kusto lagnuage service.
     * @param schema result of show schema
     * @param clusterConnectionString cluster connection string`
     * @param databaseInContextName database in context name
     */
    normalizeSchema(
        schema: s.showSchema.Result,
        clusterConnectionString: string,
        databaseInContextName: string
    ): Promise<s.EngineSchema> {
        const databases: s.EngineSchema['cluster']['databases'] = Object.keys(schema.Databases)
            .map((key) => schema.Databases[key])
            .map(({ Name, Tables, Functions, MinorVersion, MajorVersion }: s.showSchema.Database) => ({
                name: Name,
                minorVersion: MinorVersion,
                majorVersion: MajorVersion,
                tables: Object.keys(Tables)
                    .map((key) => Tables[key])
                    .map(({ Name, OrderedColumns }: s.showSchema.Table) => ({
                        name: Name,
                        columns: OrderedColumns.map(({ Name, Type, CslType }: s.showSchema.Column) => ({
                            name: Name,
                            type: CslType,
                        })),
                    })),
                functions: Object.keys(Functions)
                    .map((key) => Functions[key])
                    .map(({ Name, Body, InputParameters }) => ({
                        name: Name,
                        body: Body,
                        inputParameters: InputParameters.map((inputParam) => ({
                            name: inputParam.Name,
                            type: inputParam.Type,
                            cslType: inputParam.CslType,
                            columns: inputParam.Columns
                                ? inputParam.Columns.map((col) => ({
                                      name: col.Name,
                                      type: col.Type,
                                      cslType: col.CslType,
                                  }))
                                : [],
                        })),
                    })),
            }));

        const result: s.EngineSchema = {
            clusterType: 'Engine',
            cluster: {
                connectionString: clusterConnectionString,
                databases: databases,
            },
            database: databases.filter((db) => db.name === databaseInContextName)[0],
        };

        return Promise.as(result);
    }

    getSchema() {
        return Promise.as(this._schema);
    }

    getCommandInContext(document: ls.TextDocument, cursorOffset: number): Promise<string | null> {
        return this.isIntellisenseV2()
            ? this.getCommandInContextV2(document, cursorOffset)
            : this.getCommandInContextV1(document, cursorOffset);
    }

    getCommandAndLocationInContext(document: ls.TextDocument, cursorOffset: number) {
        // We are going to remove v1 intellisense. no use to keep parity.
        if (!this.isIntellisenseV2()) {
            return Promise.as(null);
        }

        const script = this.parseDocumentV2(document);
        const block = this.getCurrentCommandV2(script, cursorOffset);
        if (!block) {
            return Promise.as(null);
        }

        const start = document.positionAt(block.Start);
        const end = document.positionAt(block.End);
        const location = ls.Location.create(document.uri, ls.Range.create(start, end));
        const text = block.Text;
        return Promise.as({
            text,
            location,
        });
    }

    getCommandInContextV1(document: ls.TextDocument, cursorOffset: number): Promise<string | null> {
        this.parseDocumentV1(document, k.ParseMode.CommandTokensOnly);
        const command = this.getCurrentCommand(document, cursorOffset);
        if (!command) {
            return Promise.as(null);
        }

        return Promise.as(command.Text);
    }

    getCommandInContextV2(document: ls.TextDocument, cursorOffset: number): Promise<string | null> {
        const script = this.parseDocumentV2(document);
        const block = this.getCurrentCommandV2(script, cursorOffset);
        if (!block) {
            return Promise.as(null);
        }

        // TODO: do we need to do tricks like V1 is doing in this.getCurrentCommand?
        return Promise.as(block.Text);
    }

    /**
     * Retrun an array of commands in document. each command contains the range and text.
     */
    getCommandsInDocument(
        document: ls.TextDocument
    ): Promise<{ absoluteStart: number; absoluteEnd: number; text: string }[]> {
        return this.isIntellisenseV2()
            ? this.getCommandsInDocumentV2(document)
            : this.getCommandsInDocumentV1(document);
    }

    getCommandsInDocumentV1(
        document: ls.TextDocument
    ): Promise<{ absoluteStart: number; absoluteEnd: number; text: string }[]> {
        this.parseDocumentV1(document, k.ParseMode.CommandTokensOnly);
        let commands = this.toArray(this._parser.Results);
        return Promise.as(
            commands.map(({ AbsoluteStart, AbsoluteEnd, Text }) => ({
                absoluteStart: AbsoluteStart,
                absoluteEnd: AbsoluteEnd,
                text: Text,
            }))
        );
    }

    getCommandsInDocumentV2(
        document: ls.TextDocument
    ): Promise<{ absoluteStart: number; absoluteEnd: number; text: string }[]> {
        const script = this.parseDocumentV2(document);
        let commands = this.toArray<k2.CodeBlock>(script.Blocks).filter((command) => command.Text.trim() != '');
        return Promise.as(
            commands.map(({ Start, End, Text }) => ({ absoluteStart: Start, absoluteEnd: End, text: Text }))
        );
    }

    getClientDirective(text: string): Promise<{ isClientDirective: boolean; directiveWithoutLeadingComments: string }> {
        let outParam: { v: string | null } = { v: null };
        const isClientDirective = k.CslCommandParser.IsClientDirective(text, outParam);
        return Promise.as({
            isClientDirective,
            directiveWithoutLeadingComments: outParam.v,
        });
    }

    getAdminCommand(text: string): Promise<{ isAdminCommand: boolean; adminCommandWithoutLeadingComments: string }> {
        let outParam: { v: string | null } = { v: null };
        const isAdminCommand = k.CslCommandParser.IsAdminCommand$1(text, outParam);
        return Promise.as({
            isAdminCommand,
            adminCommandWithoutLeadingComments: outParam.v,
        });
    }

    findDefinition(document: ls.TextDocument, position: ls.Position): Promise<ls.Location[]> {
        if (!this.isIntellisenseV2()) {
            return Promise.as([]);
        }

        const script = this.parseDocumentV2(document);
        const cursorOffset = document.offsetAt(position);
        let currentBlock = this.getCurrentCommandV2(script, cursorOffset);

        if (!currentBlock) {
            return Promise.as([]);
        }

        const relatedInfo = currentBlock.Service.GetRelatedElements(document.offsetAt(position));
        const relatedElements = this.toArray<k2.RelatedElement>(relatedInfo.Elements);

        const definition = relatedElements[0];

        if (!definition) {
            return Promise.as([]);
        }

        const start = document.positionAt(definition.Start);
        const end = document.positionAt(definition.End);
        const range = ls.Range.create(start, end);
        const location = ls.Location.create(document.uri, range);
        return Promise.as([location]);
    }

    findReferences(document: ls.TextDocument, position: ls.Position): Promise<ls.Location[]> {
        if (!this.isIntellisenseV2()) {
            return Promise.as([]);
        }

        const script = this.parseDocumentV2(document);
        const cursorOffset = document.offsetAt(position);
        let currentBlock = this.getCurrentCommandV2(script, cursorOffset);

        if (!currentBlock) {
            return Promise.as([]);
        }

        const relatedInfo = currentBlock.Service.GetRelatedElements(document.offsetAt(position));
        const relatedElements = this.toArray<k2.RelatedElement>(relatedInfo.Elements);

        if (!relatedElements || relatedElements.length == 0) {
            return Promise.as([]);
        }

        const references = relatedElements.map((relatedElement) => {
            const start = document.positionAt(relatedElement.Start);
            const end = document.positionAt(relatedElement.End);
            const range = ls.Range.create(start, end);
            const location = ls.Location.create(document.uri, range);
            return location;
        });

        return Promise.as(references);
    }

    getQueryParams(document: ls.TextDocument, cursorOffset: number): Promise<{ name: string; type: string }[]> {
        if (!this.isIntellisenseV2()) {
            return Promise.as([]);
        }

        const script = this.parseDocumentV2(document);

        const parsedAndAnalyzed = this.parseAndAnalyze(document, cursorOffset);

        const queryParamStatements = this.toArray(
            parsedAndAnalyzed.Syntax.GetDescendants(Kusto.Language.Syntax.QueryParametersStatement)
        );
        if (!queryParamStatements || queryParamStatements.length == 0) {
            return Promise.as([]);
        }

        const queryParams = [];
        queryParamStatements.forEach((paramStatement: Kusto.Language.Syntax.QueryParametersStatement) => {
            paramStatement.WalkElements((el: any) =>
                el.ReferencedSymbol && el.ReferencedSymbol.Type
                    ? queryParams.push({ name: el.ReferencedSymbol.Name, type: el.ReferencedSymbol.Type.Name })
                    : undefined
            );
        });

        return Promise.as(queryParams);
    }

    getRenderInfo(document: ls.TextDocument, cursorOffset: number): Promise<RenderInfo | undefined> {
        const parsedAndAnalyzed = this.parseAndAnalyze(document, cursorOffset);
        if (!parsedAndAnalyzed) {
            return Promise.as(undefined);
        }

        const renderStatements = this.toArray(
            parsedAndAnalyzed.Syntax.GetDescendants(Kusto.Language.Syntax.RenderOperator)
        );

        if (!renderStatements || renderStatements.length === 0) {
            return Promise.as(undefined);
        }

        // assuming a single render statement
        const renderStatement = renderStatements[0] as Kusto.Language.Syntax.RenderOperator;

        // Start and end relative to block start.
        const startOffset = renderStatement.TextStart;
        const endOffset = renderStatement.End;

        const visualization: VisualizationType = renderStatement.ChartType.Text as VisualizationType;

        const withClause = renderStatement.WithClause;

        if (!withClause) {
            const info: RenderInfo = {
                options: {
                    visualization,
                },
                location: { startOffset, endOffset },
            };

            return Promise.as(info);
        }

        const properties = this.toArray(withClause.Properties);

        const props = properties.reduce(
            (
                prev: RenderOptions,
                property: Kusto.Language.Syntax.SeparatedElement$1<Kusto.Language.Syntax.NamedParameter>
            ) => {
                const name = property.Element$1.Name.SimpleName as RenderOptionKeys;

                switch (name) {
                    case 'xcolumn':
                        const value = property.Element$1.Expression.ReferencedSymbol.Name;
                        prev[name] = value;
                        break;
                    case 'ycolumns':
                    case 'anomalycolumns':
                        const nameNodes = this.toArray(
                            (property.Element$1.Expression as Kusto.Language.Syntax.RenderNameList).Names
                        );

                        const values = nameNodes.map(
                            (
                                nameNode: Kusto.Language.Syntax.SeparatedElement$1<
                                    Kusto.Language.Syntax.NameDeclaration
                                >
                            ) => nameNode.Element$1.SimpleName
                        );
                        prev[name] = values;
                        break;
                    case 'ymin':
                    case 'ymax':
                        const numericVal = parseFloat(property.Element$1.Expression.ConstantValue);
                        prev[name] = numericVal;
                        break;
                    case 'title':
                    case 'xtitle':
                    case 'ytitle':
                    case 'visualization':
                    case 'series':
                        const strVal = property.Element$1.Expression.ConstantValue;
                        prev[name] = strVal;
                        break;
                    case 'xaxis':
                    case 'yaxis':
                        const scale = property.Element$1.Expression.ConstantValue;
                        prev[name] = scale;
                        break;
                    case 'legend':
                        const legend = property.Element$1.Expression.ConstantValue;
                        prev[name] = legend;
                        break;
                    case 'ySplit':
                        const split = property.Element$1.Expression.ConstantValue;
                        prev[name] = split;
                        break;
                    case 'accumulate':
                        const accumulate = property.Element$1.Expression.ConstantValue;
                        prev[name] = accumulate;
                        break;
                    case 'kind':
                        const val = property.Element$1.Expression.ConstantValue;
                        prev[name] = val;
                        break;
                    default:
                        assertNever(name);
                }

                return prev;
            },
            {} as RenderOptions
        );

        const renderOptions: RenderOptions = { visualization, ...props };
        const renderInfo: RenderInfo = {
            options: renderOptions,
            location: { startOffset, endOffset },
        };
        return Promise.as(renderInfo);
    }

    getReferencedGlobalParams(
        document: ls.TextDocument,
        cursorOffset: number
    ): Promise<{ name: string; type: string }[]> {
        if (!this.isIntellisenseV2()) {
            return Promise.as([]);
        }

        const script = this.parseDocumentV2(document);
        let currentBlock = this.getCurrentCommandV2(script, cursorOffset);

        if (!currentBlock) {
            return Promise.as([]);
        }

        const text = currentBlock.Text;

        const parsedAndAnalyzed = Kusto.Language.KustoCode.ParseAndAnalyze(text, this._kustoJsSchemaV2);

        // We take the ambient parameters
        const ambientParameters = this.toArray<sym.ParameterSymbol>(this._kustoJsSchemaV2.Parameters);

        // We take all referenced symbols in the query
        const referencedSymbols = this.toArray<Kusto.Language.Syntax.SyntaxNode>(
            parsedAndAnalyzed.Syntax.GetDescendants(Kusto.Language.Syntax.Expression)
        )
            .filter((epression) => epression.ReferencedSymbol !== null)
            .map((x) => x.ReferencedSymbol) as sym.ParameterSymbol[];

        // The Intersection between them is the ambient parameters that are used in the query.
        // Note: Ideally we would use Set here (or at least array.Include), but were' compiling down to es2015.
        const intersection = referencedSymbols.filter(
            (referencedSymbol) =>
                ambientParameters.filter((ambientParameter) => ambientParameter === referencedSymbol).length > 0
        );

        const result = intersection.map((param) => ({ name: param.Name, type: param.Type.Name }));
        return Promise.as(result);
    }

    getGlobalParams(document: ls.TextDocument): Promise<{ name: string; type: string }[]> {
        if (!this.isIntellisenseV2()) {
            return Promise.as([]);
        }

        const params = this.toArray<sym.ParameterSymbol>(this._kustoJsSchemaV2.Parameters);
        const result = params.map((param) => ({ name: param.Name, type: param.Type.Name }));
        return Promise.as(result);
    }

    doRename(document: ls.TextDocument, position: ls.Position, newName: string): Promise<ls.WorkspaceEdit | undefined> {
        if (!this.isIntellisenseV2()) {
            return Promise.as(undefined);
        }

        const script = this.parseDocumentV2(document);
        const cursorOffset = document.offsetAt(position);
        let currentBLock = this.getCurrentCommandV2(script, cursorOffset);

        if (!currentBLock) {
            return Promise.as(undefined);
        }

        const relatedInfo = currentBLock.Service.GetRelatedElements(document.offsetAt(position));

        const relatedElements = this.toArray<k2.RelatedElement>(relatedInfo.Elements);
        const declarations = relatedElements.filter((e) => e.Kind == k2.RelatedElementKind.Declaration);

        // A declaration must be one of the elements
        if (!declarations || declarations.length == 0) {
            return Promise.as(undefined);
        }

        const edits = relatedElements.map((edit) => {
            const start = document.positionAt(edit.Start);
            const end = document.positionAt(edit.End);
            const range = ls.Range.create(start, end);
            return ls.TextEdit.replace(range, newName);
        });

        // create a workspace edit
        const workspaceEdit: ls.WorkspaceEdit = { changes: { [document.uri]: edits } };
        return Promise.as(workspaceEdit);
    }

    doHover(document: ls.TextDocument, position: ls.Position): Promise<ls.Hover | undefined> {
        if (!this.isIntellisenseV2()) {
            return Promise.as(undefined);
        }

        const script = this.parseDocumentV2(document);
        const cursorOffset = document.offsetAt(position);
        let currentBLock = this.getCurrentCommandV2(script, cursorOffset);

        if (!currentBLock) {
            return Promise.as(undefined);
        }

        const isSupported = currentBLock.Service.IsFeatureSupported(k2.CodeServiceFeatures.QuickInfo, cursorOffset);

        if (!isSupported) {
            return Promise.as(undefined);
        }

        const quickInfo = currentBLock.Service.GetQuickInfo(cursorOffset);

        if (!quickInfo || !quickInfo.Text) {
            return Promise.as(undefined);
        }

        return Promise.as({ contents: quickInfo.Text });
    }

    //#region dummy schema for manual testing
    static get dummySchema() {
        const database: Database = {
            majorVersion: 0,
            minorVersion: 0,
            name: 'Kuskus',
            tables: [
                {
                    name: 'KustoLogs',
                    columns: [
                        {
                            name: 'Source',
                            type: 'string',
                        },
                        {
                            name: 'Timestamp',
                            type: 'datetime',
                        },
                        {
                            name: 'Directory',
                            type: 'string',
                        },
                    ],
                },
            ],
            functions: [
                {
                    name: 'HowBig',
                    inputParameters: [
                        {
                            name: 'T',
                            columns: [
                                {
                                    name: 'Timestamp',
                                    type: 'System.DateTime',
                                    cslType: 'datetime',
                                },
                            ],
                        },
                    ],
                    body:
                        "{\r\n    union \r\n    (T | count | project V='Volume', Metric = strcat(Count/1e9, ' Billion records')),\r\n    (T | summarize FirstRecord=min(Timestamp)| project V='Volume', Metric = strcat(toint((now()-FirstRecord)/1d), ' Days of data (from: ', format_datetime(FirstRecord, 'yyyy-MM-dd'),')')),\r\n    (T | where Timestamp > ago(1h) | count | project V='Velocity', Metric = strcat(Count/1e6, ' Million records / hour')),\r\n    (T | summarize Latency=now()-max(Timestamp) | project V='Velocity', Metric = strcat(Latency / 1sec, ' seconds latency')),\r\n    (T | take 1 | project V='Variety', Metric=tostring(pack_all()))\r\n    | order by V \r\n}",
                },
                {
                    name: 'FindCIDPast24h',
                    inputParameters: [
                        {
                            name: 'clientActivityId',
                            type: 'System.String',
                            cslType: 'string',
                        },
                    ],
                    body: '{ KustoLogs | where Timestamp > now(-1d) | where ClientActivityId == clientActivityId}   ',
                },
            ],
        };

        const languageServiceSchema: s.EngineSchema = {
            clusterType: 'Engine',
            cluster: {
                connectionString: 'https://kuskus.kusto.windows.net;fed=true',
                databases: [database],
            },
            database: database,
        };

        return languageServiceSchema;
    }
    //#endregion

    private static convertToEntityDataType(kustoType: string) {}
    /**
     * We do not want to expose Bridge.Net generated schema, so we expose a cleaner javascript schema.
     * Here it gets converted to the bridge.Net schema
     * @param schema Language Service schema
     */
    private static convertToKustoJsSchema(schema: s.Schema): k.KustoIntelliSenseQuerySchema | CmSchema | undefined {
        switch (schema.clusterType) {
            case 'Engine':
                const currentDatabaseName = schema.database ? schema.database.name : undefined;
                const kCluster = new k.KustoIntelliSenseClusterEntity();
                let kDatabaseInContext: k.KustoIntelliSenseDatabaseEntity = undefined;

                kCluster.ConnectionString = schema.cluster.connectionString;
                const databases = [];
                schema.cluster.databases.forEach((database) => {
                    const kDatabase = new k.KustoIntelliSenseDatabaseEntity();
                    kDatabase.Name = database.name;
                    const tables = [];
                    database.tables.forEach((table) => {
                        const kTable = new k.KustoIntelliSenseTableEntity();
                        kTable.Name = table.name;
                        const cols = [];
                        table.columns.forEach((column) => {
                            const kColumn = new k.KustoIntelliSenseColumnEntity();
                            kColumn.Name = column.name;
                            kColumn.TypeCode = k.EntityDataType[getEntityDataTypeFromCslType(column.type)];
                            cols.push(kColumn);
                        });
                        kTable.Columns = new Bridge.ArrayEnumerable(cols);
                        tables.push(kTable);
                    });
                    const functions = [];
                    database.functions.forEach((fn) => {
                        const kFunction = new k.KustoIntelliSenseFunctionEntity();
                        (kFunction.Name = fn.name),
                            (kFunction.CallName = s.getCallName(fn)),
                            (kFunction.Expression = s.getExpression(fn)),
                            functions.push(kFunction);
                    });

                    kDatabase.Tables = new Bridge.ArrayEnumerable(tables);
                    kDatabase.Functions = new Bridge.ArrayEnumerable(functions);
                    databases.push(kDatabase);

                    if (database.name == currentDatabaseName) {
                        kDatabaseInContext = kDatabase;
                    }
                });
                kCluster.Databases = new Bridge.ArrayEnumerable(databases);
                const kSchema = new k.KustoIntelliSenseQuerySchema(kCluster, kDatabaseInContext);
                return kSchema;
            case 'ClusterManager':
                const accounts = schema.accounts.map((account) => {
                    const kAccount = new k.KustoIntelliSenseAccountEntity();
                    kAccount.Name = account;
                    return kAccount;
                });

                const services = schema.services.map((service) => {
                    const kService = new k.KustoIntelliSenseServiceEntity();
                    kService.Name = service;
                    return kService;
                });

                const connectionString = schema.connectionString;

                const result: CmSchema = {
                    accounts,
                    services,
                    connectionString,
                };
                return result;
            case 'DataManagement':
                return undefined;
            default:
                return assertNever(schema);
        }
    }

    /**
     * Returns something like '(x: string, y: datetime)'
     * @param params scalar parameters
     */
    private static scalarParametersToSignature(params: s.ScalarParameter[]) {
        const signatureWithoutParens = params.map((param) => `${param.name}: ${param.cslType}`).join(', ');
        return `(${signatureWithoutParens})`;
    }

    /**
     * Returns something like '(x: string, T: (y: int))'
     * @param params input parameters (tabular or scalar)
     */
    private static inputParameterToSignature(params: s.InputParameter[]) {
        const signatureWithoutParens = params
            .map((param) => {
                if (param.columns) {
                    const tableSignature = this.scalarParametersToSignature(param.columns);
                    return `${param.name}: ${tableSignature}`;
                } else {
                    return `${param.name}: ${param.cslType}`;
                }
            })
            .join(', ');
        return `(${signatureWithoutParens})`;
    }

    /**
     * converts a function definition to a let statement.
     * @param fn function
     */
    private static toLetStatement(fn: s.Function): string {
        const signature = this.inputParameterToSignature(fn.inputParameters);
        return `let ${fn.name} = ${signature} ${fn.body}`;
    }

    private static createColumnSymbol(col: s.ScalarParameter): sym.ColumnSymbol {
        return new sym.ColumnSymbol(col.name, sym.ScalarTypes.GetSymbol(getCslTypeNameFromClrType(col.type)), null);
    }

    private static createParameterSymbol(param: s.ScalarParameter): sym.ParameterSymbol {
        const paramSymbol: sym.ScalarSymbol = Kusto.Language.Symbols.ScalarTypes.GetSymbol(
            getCslTypeNameFromClrType(param.type)
        );
        return new sym.ParameterSymbol(param.name, paramSymbol, null);
    }

    private static createParameter(param: s.InputParameter): sym.Parameter {
        if (!param.columns) {
            const paramSymbol: sym.ScalarSymbol = Kusto.Language.Symbols.ScalarTypes.GetSymbol(
                getCslTypeNameFromClrType(param.type)
            );
            return new sym.Parameter.$ctor2(param.name, paramSymbol);
        }

        if (param.columns.length == 0) {
            return new sym.Parameter.ctor(
                param.name,
                sym.ParameterTypeKind.Tabular,
                sym.ArgumentKind.Expression,
                null,
                null,
                false,
                null,
                1,
                1,
                null,
                null
            );
        }

        const argumentType = new sym.TableSymbol.ctor(
            param.columns.map((col) => KustoLanguageService.createColumnSymbol(col))
        );
        return new sym.Parameter.$ctor2(param.name, argumentType);
    }

    private static convertToDatabaseSymbol(
        db: s.Database,
        globalState: GlobalState,
        addFunctions: boolean
    ): sym.DatabaseSymbol {
        const createFunctionSymbol: (fn: s.Function) => sym.FunctionSymbol = (fn) => {
            const parameters: sym.Parameter[] = fn.inputParameters.map((param) =>
                KustoLanguageService.createParameter(param)
            );

            // TODO: handle outputColumns (right now it doesn't seem to be implemented for any function).
            return new sym.FunctionSymbol.$ctor16(fn.name, fn.body, parameters, null);
        };

        const createTableSymbol: (tbl: s.Table) => sym.TableSymbol = (tbl) => {
            const columnSymbols = tbl.columns.map((col) => KustoLanguageService.createColumnSymbol(col));
            return new sym.TableSymbol.$ctor3(tbl.name, columnSymbols);
        };

        const createDatabaseSymbol: (db: s.Database) => sym.DatabaseSymbol = (db) => {
            const tableSymbols: sym.Symbol[] = db.tables.map((tbl) => createTableSymbol(tbl));
            const functionSymbols = db.functions.map((fun) => createFunctionSymbol(fun));
            return new sym.DatabaseSymbol.ctor(db.name, tableSymbols.concat(functionSymbols));
        };

        const databaseSymbol = createDatabaseSymbol(db);

        return databaseSymbol;
    }

    private convertToKustoJsSchemaV2(schema: s.EngineSchema): GlobalState {
        let cached = this._schemaCache[schema.cluster.connectionString];

        // create a cache entry for the cluster if non yet exists.
        if (!cached) {
            this._schemaCache[schema.cluster.connectionString] = {};
            cached = this._schemaCache[schema.cluster.connectionString];
        }

        // Remove deleted databases from cache
        const schemaDbLookup: { [dbName: string]: s.Database } = schema.cluster.databases.reduce(
            (prev, curr) => (prev[curr.name] = curr),
            {}
        );
        Object.keys(cached).map((dbName) => {
            if (!schemaDbLookup[dbName]) {
                delete cached.dbName;
            }
        });

        let globalState = GlobalState.Default;
        const currentDatabaseName = schema.database ? schema.database.name : undefined;

        let databaseInContext: sym.DatabaseSymbol | undefined = undefined;

        // Update out-of-data databses to cache
        const databases = schema.cluster.databases.map((db) => {
            const shouldIncludeFunctions = db.name === currentDatabaseName;

            const cachedDb = cached[db.name];
            // This is an older version than we have, or we need to parse functions.
            if (
                !cachedDb ||
                cachedDb.database.majorVersion < db.majorVersion ||
                (shouldIncludeFunctions && !cachedDb.includesFunctions)
            ) {
                // only add functions for the database in context (it's very time consuming)

                const databaseSymbol = KustoLanguageService.convertToDatabaseSymbol(
                    db,
                    globalState,
                    shouldIncludeFunctions
                );
                cached[db.name] = { database: db, symbol: databaseSymbol, includesFunctions: shouldIncludeFunctions };
            }

            const databaseSymbol = cached[db.name].symbol;
            if (db.name === currentDatabaseName) {
                databaseInContext = databaseSymbol;
            }

            return databaseSymbol;
        });

        // Replace new URL due to polyfill issue in IE
        // const hostname = new URL(schema.cluster.connectionString.split(';')[0]).hostname;
        const hostname = schema.cluster.connectionString.match(/(.*\/\/)?([^\/;]*)/)[2];
        const clusterName = hostname.split('.')[0];
        const clusterSymbol = new sym.ClusterSymbol.ctor(clusterName, databases);

        globalState = globalState.WithCluster(clusterSymbol);

        if (databaseInContext) {
            globalState = globalState.WithDatabase(databaseInContext);
        }

        // Inject gloabl parameters to global scope.
        if (schema.globalParameters) {
            const parameters = schema.globalParameters.map((param) =>
                KustoLanguageService.createParameterSymbol(param)
            );
            globalState = globalState.WithParameters(parameters);
        }

        return globalState;
    }

    private getClassificationsFromParseResult(offset: number = 0) {
        const classifications = this.toArray(this._parser.Results)
            .map((command) => this.toArray(command.Tokens))
            .reduce((prev, curr) => prev.concat(curr), [])
            .map(
                (cslCommandToken): k2.ClassifiedRange => {
                    const range = new k2.ClassifiedRange(
                        this.tokenKindToClassificationKind(cslCommandToken.TokenKind),
                        cslCommandToken.AbsoluteStart + offset,
                        cslCommandToken.Length
                    );
                    // todo: shouldn't we remove it
                    range.End = cslCommandToken.AbsoluteEnd + offset;

                    return range;
                }
            );

        return classifications;
    }

    /**
     * trim trailing newlines from range
     */
    private static trimTrailingNewlineFromRange(
        textInRange: string,
        rangeStartOffset: number,
        document: ls.TextDocument,
        range: ls.Range
    ) {
        let currentIndex = textInRange.length - 1;
        while (textInRange[currentIndex] === '\r' || textInRange[currentIndex] === '\n') {
            --currentIndex;
        }
        const newEndOffset = rangeStartOffset + currentIndex + 1;
        const newEndPosition = document.positionAt(newEndOffset);
        const newRange = ls.Range.create(range.start, newEndPosition);
        return newRange;
    }

    /**
     * Maps numbers to strings, such that if a>b numerically, f(a)>f(b) lexicograhically.
     * 1 -> "a", 26 -> "z", 27 -> "za", 28 -> "zb", 52 -> "zz", 53 ->"zza"
     * @param order - The number to be converted to a sorting-string. order should start at 1.
     * @returns A string repenting the order.
     */
    private getSortText(order: number): string {
        if (order <= 0) {
            throw new RangeError(`order should be a number >= 1. instead got ${order}`);
        }

        let sortText = '';
        let numCharacters = 26; // "z" - "a" + 1;

        let div = Math.floor(order / numCharacters);

        for (let i = 0; i < div; ++i) {
            sortText += 'z';
        }

        let reminder = order % numCharacters;

        if (reminder > 0) {
            sortText += String.fromCharCode(96 + reminder);
        }

        return sortText;
    }

    /**
     * ParseTextV1 parses the given text with the given parse mode.
     * Additionally - it will make sure not to provide rules provider for non-engine clusters
     * since the only rules provider parse can handle is the engine's. It will try to look for function
     * definitions to colorize and will throw since they're not there.
     * @param text
     * @param parseMode
     */
    private parseTextV1(text: string, parseMode: k.ParseMode) {
        this._parser.Parse(
            this._schema.clusterType === 'Engine' ? (this._rulesProvider as any) : null,
            text,
            parseMode
        );
    }

    private parseDocumentV1(document: ls.TextDocument, parseMode: k.ParseMode) {
        // already parsed a later version, or better parse mode for this uri
        if (
            this._parsePropertiesV1 &&
            !this._parsePropertiesV1.isParseNeeded(document, this._rulesProvider, parseMode)
        ) {
            return;
        }

        this.parseTextV1(document.getText(), parseMode);

        this._parsePropertiesV1 = new ParseProperties(document.version, document.uri, this._rulesProvider, parseMode);
    }

    private parseDocumentV2(document: ls.TextDocument) {
        if (this._parsePropertiesV2 && !this._parsePropertiesV2.isParseNeeded(document, this._rulesProvider)) {
            return this._script;
        }

        if (!this._script) {
            this._script = k2.CodeScript.From$1(document.getText(), this._kustoJsSchemaV2);
        } else {
            this._script = this._script.WithText(document.getText());
        }

        this._parsePropertiesV2 = new ParseProperties(document.version, document.uri);

        return this._script;
    }

    /**
     * Return the CslCommand that wraps the caret location, or undefined if caret is outside any command
     * @param document the document to extract the current command from
     * @param caretAbsolutePosition absolute caret position
     */
    private getCurrentCommand(document: ls.TextDocument, caretAbsolutePosition: number): k.CslCommand | undefined {
        let commands = this.toArray(this._parser.Results);

        let command = commands.filter(
            (command) => command.AbsoluteStart <= caretAbsolutePosition && command.AbsoluteEnd >= caretAbsolutePosition
        )[0];

        // There is an edge case when cursor appears at the end of the command
        // which is not yet considered to be part of the parsed command (therefore: +1 for the AbsoluteEdit property)
        if (!command) {
            command = commands.filter(
                (command) =>
                    command.AbsoluteStart <= caretAbsolutePosition && command.AbsoluteEnd + 1 >= caretAbsolutePosition
            )[0];

            // If we have 2 newlines in the end of the text the cursor is _probably_ at the end of the text
            // which this means that we're not actually standing on any command. Thus return null.
            if (!command || command.Text.endsWith('\r\n\r\n')) {
                return null;
            }
        }

        return command;
    }

    private getCurrentCommandV2(script: k2.CodeScript, offset: number) {
        let block = script.GetBlockAtPosition(offset);

        return block;
    }

    private getTextToInsert(
        rule: k.IntelliSenseRule,
        option: k.CompletionOption
    ): { insertText: string; insertTextFormat: ls.InsertTextFormat } {
        const beforeApplyInfo = rule.GetBeforeApplyInfo(option.Value);
        const afterApplyInfo = rule.GetAfterApplyInfo(option.Value);

        // this is the basic text to be insterted,
        // but we still need to figure out where the cursor will end up after completion is applied.
        let insertText = beforeApplyInfo.Text || '' + option.Value + afterApplyInfo.Text || '';
        let insertTextFormat: ls.InsertTextFormat = ls.InsertTextFormat.PlainText;

        const snippetFinalTabStop = '$0';
        if (afterApplyInfo.OffsetToken && afterApplyInfo.OffsetPosition) {
            const tokenOffset = insertText.indexOf(afterApplyInfo.OffsetToken);
            if (tokenOffset >= 0) {
                insertText = this.insertToString(
                    insertText,
                    snippetFinalTabStop,
                    tokenOffset - insertText.length + afterApplyInfo.OffsetPosition
                );
                insertTextFormat = ls.InsertTextFormat.Snippet;
            }
        } else if (afterApplyInfo.OffsetPosition) {
            // We only handle negative offsets
            insertText = this.insertToString(insertText, snippetFinalTabStop, afterApplyInfo.OffsetPosition);
            insertTextFormat = ls.InsertTextFormat.Snippet;
        }

        return { insertText, insertTextFormat };
    }

    /**
     * create a new string with stringToInsert inserted at offsetFromEnd in originalString.
     * @param originalString string to insert to
     * @param stringToInsert string to insert
     * @param offsetFromEnd a negative number that will represent offset to the left. 0 means simple concat
     */
    private insertToString(originalString: string, stringToInsert: string, offsetFromEnd: number): string {
        var index = originalString.length + offsetFromEnd;

        if (offsetFromEnd >= 0 || index < 0) {
            return originalString; // Cannot insert before or after the string
        }

        var before = originalString.substring(0, index);
        var after = originalString.substring(index);

        return before + stringToInsert + after;
    }

    private getCommandWithoutLastWord(text: string): string {
        const lastWordRegex = XRegExp('[\\w_]*$', 's');
        return text.replace(lastWordRegex, '');
    }

    private createRulesProvider(
        schema: k.KustoIntelliSenseQuerySchema | CmSchema | undefined,
        clusterType: s.ClusterType
    ) {
        var queryParameters: any = new (List(String))();
        var availableClusters: any = new (List(String))();
        this._parser = new k.CslCommandParser();

        if (clusterType == 'Engine') {
            const engineSchema = schema as k.KustoIntelliSenseQuerySchema;
            this._rulesProvider =
                this._languageSettings && this._languageSettings.includeControlCommands
                    ? new k.CslIntelliSenseRulesProvider.$ctor1(
                          engineSchema.Cluster,
                          engineSchema,
                          queryParameters,
                          availableClusters,
                          null,
                          true,
                          true
                      )
                    : new k.CslQueryIntelliSenseRulesProvider.$ctor1(
                          engineSchema.Cluster,
                          engineSchema,
                          queryParameters,
                          availableClusters,
                          null,
                          null,
                          null
                      );
            return;
        }

        if (clusterType === 'DataManagement') {
            this._rulesProvider = new k.DataManagerIntelliSenseRulesProvider(null);
            return;
        }

        // This is a cluster manger
        const { accounts, services, connectionString } = schema as CmSchema;
        new k.KustoIntelliSenseAccountEntity();
        new k.KustoIntelliSenseServiceEntity();
        this._rulesProvider = new k.ClusterManagerIntelliSenseRulesProvider.$ctor1(
            new Bridge.ArrayEnumerable(accounts),
            new Bridge.ArrayEnumerable(services),
            connectionString
        );
    }

    private _kustoKindtolsKind = {
        [k.OptionKind.None]: ls.CompletionItemKind.Interface,
        [k.OptionKind.Operator]: ls.CompletionItemKind.Method,
        [k.OptionKind.Command]: ls.CompletionItemKind.Method,
        [k.OptionKind.Service]: ls.CompletionItemKind.Class,
        [k.OptionKind.Policy]: ls.CompletionItemKind.Reference,
        [k.OptionKind.Database]: ls.CompletionItemKind.Class,
        [k.OptionKind.Table]: ls.CompletionItemKind.Class,
        [k.OptionKind.DataType]: ls.CompletionItemKind.Class,
        [k.OptionKind.Literal]: ls.CompletionItemKind.Property,
        [k.OptionKind.Parameter]: ls.CompletionItemKind.Variable,
        [k.OptionKind.IngestionMapping]: ls.CompletionItemKind.Variable,
        [k.OptionKind.ExpressionFunction]: ls.CompletionItemKind.Variable,
        [k.OptionKind.Option]: ls.CompletionItemKind.Interface,
        [k.OptionKind.OptionKind]: ls.CompletionItemKind.Interface,
        [k.OptionKind.OptionRender]: ls.CompletionItemKind.Interface,
        [k.OptionKind.Column]: ls.CompletionItemKind.Function,
        [k.OptionKind.ColumnString]: ls.CompletionItemKind.Field,
        [k.OptionKind.ColumnNumeric]: ls.CompletionItemKind.Field,
        [k.OptionKind.ColumnDateTime]: ls.CompletionItemKind.Field,
        [k.OptionKind.ColumnTimespan]: ls.CompletionItemKind.Field,
        [k.OptionKind.FunctionServerSide]: ls.CompletionItemKind.Field,
        [k.OptionKind.FunctionAggregation]: ls.CompletionItemKind.Field,
        [k.OptionKind.FunctionFilter]: ls.CompletionItemKind.Field,
        [k.OptionKind.FunctionScalar]: ls.CompletionItemKind.Field,
        [k.OptionKind.ClientDirective]: ls.CompletionItemKind.Enum,
    };

    private _kustoKindToLsKindV2: { [k in k2.CompletionKind]: ls.CompletionItemKind } = {
        [k2.CompletionKind.AggregateFunction]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.BuiltInFunction]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.Cluster]: ls.CompletionItemKind.Class,
        [k2.CompletionKind.Column]: ls.CompletionItemKind.Function,
        [k2.CompletionKind.CommandPrefix]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.Database]: ls.CompletionItemKind.Class,
        [k2.CompletionKind.DatabaseFunction]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.Example]: ls.CompletionItemKind.Text,
        [k2.CompletionKind.Identifier]: ls.CompletionItemKind.Method,
        [k2.CompletionKind.Keyword]: ls.CompletionItemKind.Method,
        [k2.CompletionKind.LocalFunction]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.MaterialiedView]: ls.CompletionItemKind.Class,
        [k2.CompletionKind.Parameter]: ls.CompletionItemKind.Variable,
        [k2.CompletionKind.Punctuation]: ls.CompletionItemKind.Interface,
        [k2.CompletionKind.QueryPrefix]: ls.CompletionItemKind.Function,
        [k2.CompletionKind.RenderChart]: ls.CompletionItemKind.Method,
        [k2.CompletionKind.ScalarInfix]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.ScalarPrefix]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.ScalarType]: ls.CompletionItemKind.TypeParameter,
        [k2.CompletionKind.Syntax]: ls.CompletionItemKind.Method,
        [k2.CompletionKind.Table]: ls.CompletionItemKind.Class,
        [k2.CompletionKind.TabularPrefix]: ls.CompletionItemKind.Field,
        // datatable, externaldata
        [k2.CompletionKind.TabularSuffix]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.Unknown]: ls.CompletionItemKind.Interface,
        [k2.CompletionKind.Variable]: ls.CompletionItemKind.Variable,
    };

    private kustoKindToLsKind(kustoKind: k.OptionKind): ls.CompletionItemKind {
        let res = this._kustoKindtolsKind[kustoKind];
        return res ? res : ls.CompletionItemKind.Variable;
    }

    private kustoKindToLsKindV2(kustoKind: k2.CompletionKind): ls.CompletionItemKind {
        let res = this._kustoKindToLsKindV2[kustoKind];
        return res ? res : ls.CompletionItemKind.Variable;
    }

    private toArray<T>(bridgeList: System.Collections.Generic.IEnumerable$1<T>): T[] {
        return (Bridge as any).toArray(bridgeList);
    }

    private _tokenKindToClassificationKind: { [k in TokenKind]: k2.ClassificationKind } = {
        [TokenKind.TableToken]: k2.ClassificationKind.Table,
        [TokenKind.TableColumnToken]: k2.ClassificationKind.Column,
        [TokenKind.OperatorToken]: k2.ClassificationKind.QueryOperator,
        [TokenKind.SubOperatorToken]: k2.ClassificationKind.Function,
        [TokenKind.CalculatedColumnToken]: k2.ClassificationKind.Column,
        [TokenKind.StringLiteralToken]: k2.ClassificationKind.Literal,
        [TokenKind.FunctionNameToken]: k2.ClassificationKind.Function,
        [TokenKind.UnknownToken]: k2.ClassificationKind.PlainText,
        [TokenKind.CommentToken]: k2.ClassificationKind.Comment,
        [TokenKind.PlainTextToken]: k2.ClassificationKind.PlainText,
        [TokenKind.DataTypeToken]: k2.ClassificationKind.Type,
        [TokenKind.ControlCommandToken]: k2.ClassificationKind.PlainText, // TODO ?
        [TokenKind.CommandPartToken]: k2.ClassificationKind.PlainText, // TODO ?
        [TokenKind.QueryParametersToken]: k2.ClassificationKind.QueryParameter,
        [TokenKind.CslCommandToken]: k2.ClassificationKind.Keyword, // TODO ?
        [TokenKind.LetVariablesToken]: k2.ClassificationKind.Identifier, // TODO ?
        [TokenKind.PluginToken]: k2.ClassificationKind.Function,
        [TokenKind.BracketRangeToken]: k2.ClassificationKind.Keyword, // TODO ?
        [TokenKind.ClientDirectiveToken]: k2.ClassificationKind.Keyword, // TODO ?
    };
    private tokenKindToClassificationKind(token: TokenKind): k2.ClassificationKind {
        const conversion = this._tokenKindToClassificationKind[token];
        return conversion || k2.ClassificationKind.PlainText;
    }

    private parseAndAnalyze(document: ls.TextDocument, cursorOffset: number): Kusto.Language.KustoCode | undefined {
        if (!this.isIntellisenseV2()) {
            return undefined;
        }

        const script = this.parseDocumentV2(document);
        let currentBlock = this.getCurrentCommandV2(script, cursorOffset);

        if (!currentBlock) {
            return undefined;
        }

        const text = currentBlock.Text;

        const parsedAndAnalyzed = Kusto.Language.KustoCode.ParseAndAnalyze(text, this._kustoJsSchemaV2);

        return parsedAndAnalyzed;
    }
}

let languageService = new KustoLanguageService(KustoLanguageService.dummySchema, {
    includeControlCommands: true,
    useIntellisenseV2: true,
    useSemanticColorization: true,
});

/**
 * Obtain an instance of the kusto language service.
 */
export function getKustoLanguageService(): LanguageService {
    return languageService;
}
