/// <reference path="../../node_modules/@kusto/language-service/Kusto.JavaScript.Client.d.ts" />
/// <reference path="../../node_modules/@kusto/language-service-next/Kusto.Language.Bridge.d.ts" />
/// <reference path="../typings/refs.d.ts" />
import * as s from './schema';

// polyfill string endsWith
if (!String.prototype.endsWith) {
	String.prototype.endsWith = function(search, this_len) {
		if (this_len === undefined || this_len > this.length) {
			this_len = this.length;
		}
		return this.substring(this_len - search.length, this_len) === search;
	};
}

// If we're running in a web worker - which doesn't share global context with the main thread -
// we need to manually load dependencies that are not explicit- meaning our non-module dependencies
// generated by Bridge.Net
if (typeof (document) == "undefined") {
    // monaco will run the workder from vs/base/worker so the relative path needs to be from there (hence going up 2 dirs)
    importScripts('../../language/kusto/bridge.js');
    importScripts('../../language/kusto/kusto.javascript.client.js');
    importScripts('../../language/kusto/Kusto.Language.Bridge.js');
}

import Promise = monaco.Promise;
import * as ls from 'vscode-languageserver-types';
import { FoldingRange } from 'vscode-languageserver-protocol-foldingprovider';
import * as XRegExp from 'xregexp'
import k = Kusto.Data.IntelliSense;
import k2 = Kusto.Language.Editor;
import sym = Kusto.Language.Symbols;
import GlobalState = Kusto.Language.GlobalState;

import { Database, getCslTypeNameFromClrType, getEntityDataTypeFromCslType } from './schema';

let List = System.Collections.Generic.List$1;

function assertNever(x: never): never {
    throw new Error("Unexpected object: " + x);
}

class ParseProperties {

    constructor(private version: number, private uri: string, private rulesProvider?: k.IntelliSenseRulesProviderBase, private parseMode?: k.ParseMode) { }

    isParseNeeded(document: ls.TextDocument, rulesProvider?: k.IntelliSenseRulesProviderBase, parseMode?: k.ParseMode) {
        if (document.uri === this.uri && (!rulesProvider || rulesProvider === this.rulesProvider) && document.version <= this.version  && parseMode && parseMode <= this.parseMode) {
            return false;
        }

        return true;
    }
}

export enum TokenKind {
    TableToken = 2,
    TableColumnToken = 4,
    OperatorToken = 8, // where, projectm, ...
    SubOperatorToken = 16, // has, contains, ...
    CalculatedColumnToken = 32,
    StringLiteralToken = 64,
    FunctionNameToken = 128,
    UnknownToken = 256,
    CommentToken = 512,
    PlainTextToken = 1024,
    DataTypeToken = 2048,
    ControlCommandToken = 4096,
    CommandPartToken = 8192,
    QueryParametersToken = 16384,
    CslCommandToken = 32768,
    LetVariablesToken = 65536,
    PluginToken = 131072,
    BracketRangeToken = 262144,
    ClientDirectiveToken = 524288
}

/**
 * colorization data for specific line range.
 */
export interface ColorizationRange {
    classifications: k2.ClassifiedRange[];
    absoluteStart: number,
    absoluteEnd: number
};

export interface LanguageService {
    doComplete(document: ls.TextDocument, position: ls.Position): Promise<ls.CompletionList>;
    doRangeFormat(document: ls.TextDocument, range: ls.Range): Promise<ls.TextEdit[]>;
    doDocumentformat(document: ls.TextDocument): Promise<ls.TextEdit[]>;
    doCurrentCommandFormat(document: ls.TextDocument, caretPosition: ls.Position): Promise<ls.TextEdit[]>;
    doFolding(document: ls.TextDocument): Promise<FoldingRange[]>;
    doValidation(document: ls.TextDocument, intervals: {start: number, end: number}[]): Promise<ls.Diagnostic[]>;
    doColorization(document: ls.TextDocument, intervals: {start: number, end: number}[]): Promise<ColorizationRange[]>;
    setSchema(schema: s.Schema): Promise<void>;
    setSchemaFromShowSchema(
        schema: s.showSchema.Result,
        clusterConnectionString: string,
        databaseInContextName: string): Promise<void>;
    normalizeSchema(
            schema: s.showSchema.Result,
            clusterConnectionString: string,
            databaseInContextName: string): Promise<s.EngineSchema>;
    getSchema(): Promise<s.Schema>;
    getCommandInContext(document: ls.TextDocument, cursorOffset: number): Promise<string>;
    getCommandsInDocument(document: ls.TextDocument): Promise<{absoluteStart: number, absoluteEnd: number, text: string}[]>;
    configure(languageSettings: LanguageSettings);
    getClientDirective(text: string): Promise<{isClientDirective: boolean, directiveWithoutLeadingComments: string}>;
    getAdminCommand(text: string): Promise<{isAdminCommand: boolean, adminCommandWithoutLeadingComments: string}>;
}

export interface LanguageSettings {
    includeControlCommands?: boolean;
    newlineAfterPipe?: boolean;
    useIntellisenseV2: boolean;
    useSemanticColorization?: boolean;
    useTokenColorization?: boolean;
    disabledCompletionItems?: string[];
}

export type CmSchema = {
    accounts: k.KustoIntelliSenseAccountEntity[],
    services: k.KustoIntelliSenseServiceEntity[],
    connectionString: string
};


/**
 * Kusto Language service translates the kusto object model (transpiled from C# by Bridge.Net)
 * to the vscode language server types, which are used by vscode lanugage extensions.
 * This should make things easier in the future to provide a vscode extension based on this translation layer.
 *
 * Further translations, if needed, to support specific editors (Atom, sublime, Etc)
 * should be done on top of this API, since it is (at least meant to be) a standard that is supported by multiple editors.
 *
 * Note1:  Currenlty monaco isn't using this object model so further translation will be necessary on calling modules.
 *
 * Note2: This file is responsible for interacting with the kusto object model and exposing Microsoft language service types.
 * An exception to that rule is tokenization (and syntax highlighting which depends on it) -
 * since it's not currently part of the Microosft language service protocol. Thus tokenize() _does_ 'leak' kusto types to the callers.
 */
 class KustoLanguageService implements LanguageService {
    private _kustoJsSchema: k.KustoIntelliSenseQuerySchema | CmSchema | undefined;
    private _kustoJsSchemaV2: GlobalState;
    private _languageSettings: LanguageSettings;
    private _schema: s.Schema;
    private _schemaCache: {[cluster: string]: {[dbName: string]: {database: s.Database, symbol: sym.DatabaseSymbol, includesFunctions: boolean}}};
    private _parser: k.CslCommandParser;
    private _script: k2.Script;
    private _parsePropertiesV1: ParseProperties
    private _parsePropertiesV2: ParseProperties
    private _rulesProvider: k.CslIntelliSenseRulesProvider | k.CslQueryIntelliSenseRulesProvider | k.DataManagerIntelliSenseRulesProvider | k.ClusterManagerIntelliSenseRulesProvider;
    private _newlineAppendPipePolicy: Kusto.Data.IntelliSense.ApplyPolicy;
    private _toOptionKind: {[completionKind in k2.CompletionKind]: k.OptionKind} = {
        [k2.CompletionKind.AggregateFunction]: k.OptionKind.FunctionAggregation,
        [k2.CompletionKind.ClausePrefix]: k.OptionKind.None,
        [k2.CompletionKind.Cluster]: k.OptionKind.Database,
        [k2.CompletionKind.Column]: k.OptionKind.Column,
        [k2.CompletionKind.Database]: k.OptionKind.Database,
        [k2.CompletionKind.Identifier]: k.OptionKind.None,
        [k2.CompletionKind.Keyword]: k.OptionKind.None,
        [k2.CompletionKind.Literal]: k.OptionKind.Literal,
        [k2.CompletionKind.Parameter]: k.OptionKind.Parameter,
        [k2.CompletionKind.Punctuation]: k.OptionKind.None,
        [k2.CompletionKind.QueryPrefix]: k.OptionKind.Operator,
        [k2.CompletionKind.RenderChart]: k.OptionKind.Operator,
        [k2.CompletionKind.ScalarFunction]: k.OptionKind.FunctionScalar,
        [k2.CompletionKind.ScalarInfix]: k.OptionKind.None,
        [k2.CompletionKind.ScalarPrefix]: k.OptionKind.None,
        [k2.CompletionKind.Syntax]: k.OptionKind.None,
        [k2.CompletionKind.Table]: k.OptionKind.Table,
        [k2.CompletionKind.TabularFunction]: k.OptionKind.FunctionServerSide,
        [k2.CompletionKind.TabularPrefix]: k.OptionKind.None,
        [k2.CompletionKind.TabularSuffix]: k.OptionKind.None,
        [k2.CompletionKind.Unknown]: k.OptionKind.None,
        [k2.CompletionKind.Variable]: k.OptionKind.Parameter
     }

    constructor(schema: s.EngineSchema, languageSettings: LanguageSettings) {

        this._schemaCache = {};
        this._kustoJsSchema = KustoLanguageService.convertToKustoJsSchema(schema);
        this._kustoJsSchemaV2 = this.convertToKustoJsSchemaV2(schema);
        this._schema = schema;

        this.configure(languageSettings);
        this._newlineAppendPipePolicy = new Kusto.Data.IntelliSense.ApplyPolicy();
        this._newlineAppendPipePolicy.Text = '\n| ';

    }

    configure(languageSettings: LanguageSettings) {
        this._languageSettings = languageSettings;

        // Since we're still reverting to V1 intellisense for control commands, we need to update the rules provider
        // (which is a notion of V1 intellisense).
        this.createRulesProvider(this._kustoJsSchema, this._schema.clusterType);
    }

    doComplete(document: ls.TextDocument, position: ls.Position): Promise<ls.CompletionList> {
        return this._languageSettings.useIntellisenseV2
            ? this.doCompleteV2(document, position)
            :  this.doCompleteV1(document, position);
    }

    private disabledCompletionItemsV2: {[value: string]: k2.CompletionKind}= {
        // plugins
        'cosmosdb_sql_request': k2.CompletionKind.TabularFunction,
        'http_request':  k2.CompletionKind.TabularFunction,
        'http_request_post': k2.CompletionKind.TabularFunction,
        // functions
        'distance': k2.CompletionKind.ScalarFunction,
        'point': k2.CompletionKind.ScalarFunction,
        // render charts
        'anomalychart': k2.CompletionKind.Syntax,
        'areachart': k2.CompletionKind.Syntax,
        'ladderchart': k2.CompletionKind.Syntax,
        'pivotchart': k2.CompletionKind.Syntax,
        'scatterchart': k2.CompletionKind.Syntax,
        'stackedareachart': k2.CompletionKind.Syntax,
        'timeline': k2.CompletionKind.Syntax,
        'timepivot': k2.CompletionKind.Syntax,
        '3Dchart': k2.CompletionKind.Syntax,
        'list': k2.CompletionKind.Syntax
    }

    doCompleteV2(document: ls.TextDocument, position: ls.Position): Promise<ls.CompletionList> {
        const script = this.parseDocumentV2(document);
        const cursorOffset = document.offsetAt(position);
        let currentcommand = this.getCurrentCommandV2(script, cursorOffset);

        // Currently V2 only supports queries, so we'll deffer to V1 for control commands.
        // Bridge.net didn't add 'Kind' to d.ts file, so we're adding here
        if ((currentcommand as k2.ScriptBlock & {Kind: 'Query' | 'Command' | 'Directive' | 'Unknown' }).Kind !== 'Query') {
            return this.doCompleteV1(document, position);
        }

        const completionItems = currentcommand.GetCompletionItems(cursorOffset);

        let disabledItems = this.disabledCompletionItemsV2;
        if (this._languageSettings.disabledCompletionItems) {
            this._languageSettings.disabledCompletionItems.map(item => {
                // logic will treat unknown as a '*' wildcard, meaning that if the key is in the object
                // the completion item will be suppressed.
                disabledItems[item] = k2.CompletionKind.Unknown
            })
        }

        let items: ls.CompletionItem[] = this.toArray<k2.CompletionItem>(completionItems.Items)
        .filter(item => !(
            item
            && item.MatchText
            && disabledItems[item.MatchText] !== undefined
            && (disabledItems[item.MatchText] === k2.CompletionKind.Unknown ||  disabledItems[item.MatchText] === item.Kind)))
        .map((kItem, i) => {
            const v1CompletionOption = new k.CompletionOption(this._toOptionKind[kItem.Kind] || k.OptionKind.None, kItem.DisplayText);
            const helpTopic: k.CslTopicDocumentation = this.getTopic(v1CompletionOption);
            // If we have AfterText it means that the cursor should no be placed at end of suggested text.
            // In that case we switch to snippet format and represent the point where the cursor should be as
            // as '\$0'
            const {textToInsert, format} = (kItem.AfterText && kItem.AfterText.length > 0)
                ? {
                    textToInsert: kItem.EditText + '\$0' + kItem.AfterText,
                    format: ls.InsertTextFormat.Snippet
                }
                : {
                    textToInsert: kItem.EditText,
                    format: ls.InsertTextFormat.PlainText
                };

            const lsItem = ls.CompletionItem.create(kItem.DisplayText);

            const startPosition = document.positionAt(completionItems.EditStart);
            const endPosition = document.positionAt(completionItems.EditStart + completionItems.EditLength);
            lsItem.textEdit = ls.TextEdit.replace(ls.Range.create(startPosition, endPosition), textToInsert);
            lsItem.sortText = this.getSortText(i + 1);
            lsItem.kind = this.kustoKindToLsKindV2(kItem.Kind);
            lsItem.insertTextFormat = format;
            lsItem.detail = helpTopic ? helpTopic.ShortDescription : undefined;
            lsItem.documentation = helpTopic ? {value: helpTopic.LongDescription, kind: ls.MarkupKind.Markdown} : undefined;
            return lsItem;
        });

        return Promise.as(ls.CompletionList.create(items));
    }

    /**
     * when trying to get a topic we need the funtion name (abs, tolower, ETC).
     * The problem is that the 'Value' string also contains the  arguments (e.g abs(nubmer)), which means that we are
     * not able to correlate the option with its documentation.
     * This piece of code tries to strip this hwne getting topic.
     * @param completionOption the Completion option
     */
    private getTopic(completionOption: k.CompletionOption): k.CslTopicDocumentation {
        if (completionOption.Kind == k.OptionKind.FunctionScalar || completionOption.Kind == k.OptionKind.FunctionAggregation) {
            // from a value like 'abs(number)' remove the '(number)' so that only 'abs' will remain
            const indexOfParen = completionOption.Value.indexOf('(');
            if ((indexOfParen >= 0)) {
                completionOption = new k.CompletionOption(completionOption.Kind, completionOption.Value.substring(0, indexOfParen));
            }
        }

        return k.CslDocumentation.Instance.GetTopic(completionOption);
     }

    private disabledCompletionItemsV1: {[value: string]: k.OptionKind}= {
        'capacity': k.OptionKind.Policy,
        'callout': k.OptionKind.Policy,
        'encoding': k.OptionKind.Policy,
        'batching': k.OptionKind.Policy,
        'querythrottling': k.OptionKind.Policy,
        'merge': k.OptionKind.Policy,
        'querylimit': k.OptionKind.Policy,
        'rowstore': k.OptionKind.Policy,
        'streamingingestion': k.OptionKind.Policy,
        'restricted_view_access': k.OptionKind.Policy,
        'sharding': k.OptionKind.Policy,
        'restricted-viewers': k.OptionKind.Policy,
        'attach': k.OptionKind.Command,
        'purge': k.OptionKind.Command,
    }

    doCompleteV1(document: ls.TextDocument, position: ls.Position): Promise<ls.CompletionList> {
        // TODO: fix typing in CslCommandParser to allow rulesProvider to be query only.
        let caretAbsolutePosition = document.offsetAt(position);

        // find out what's the current command to only parse this one.
        this.parseDocumentV1(document, k.ParseMode.CommandTokensOnly);
        let currentCommand = this.getCurrentCommand(document, caretAbsolutePosition);

        let commandTextUntilCursor = '';
        if (currentCommand) {
            const commandStartOffset = currentCommand.AbsoluteStart;
            this.parseTextV1(currentCommand.Text, k.ParseMode.TokenizeAllText);
            const caretRelativePosition = caretAbsolutePosition - currentCommand.AbsoluteStart;
            commandTextUntilCursor = currentCommand.Text.substring(currentCommand.CslExpressionStartPosition, caretRelativePosition);
        }

        let commandTextWithoutLastWord = this.getCommandWithoutLastWord(commandTextUntilCursor);

        let context = this._rulesProvider.AnalyzeCommand$1(commandTextUntilCursor, currentCommand).Context;

        let  result = { v: null };
        this._rulesProvider.TryMatchAnyRule(commandTextWithoutLastWord, result);
        let rule: k.IntelliSenseRule = result.v;

        if (rule) {
            const completionOptions = this.toArray(rule.GetCompletionOptions(context));

            // TODO once AppendPipePolicy becomes a public static member of ApplyPolicy in our c# code, and bridge.Net transplies this,
            //  remove the 'as any' part..
            // Also = DefaultApplyPolicy is internal in c# code, so not exposed in d.ts, so we cast it to any.
            if (this._languageSettings.newlineAfterPipe && (rule as any).DefaultAfterApplyPolicy === (Kusto.Data.IntelliSense.ApplyPolicy as any).AppendPipePolicy) {
                (rule as any).DefaultAfterApplyPolicy = this._newlineAppendPipePolicy;
            };

            let options: ls.CompletionItem[] = completionOptions
            .filter(option => !(
                option
                && option.Value
                && this.disabledCompletionItemsV1[option.Value] === option.Kind))
            .map((option: k.CompletionOption, ordinal:number) => {
                const { insertText, insertTextFormat } = this.getTextToInsert(rule, option)
                const helpTopic: k.CslTopicDocumentation = k.CslDocumentation.Instance.GetTopic(option);
                const item = ls.CompletionItem.create(option.Value);
                item.kind = this.kustoKindToLsKind(option.Kind);
                item.insertText = insertText;
                item.insertTextFormat = insertTextFormat;
                item.sortText = this.getSortText(ordinal + 1);
                item.detail = helpTopic ? helpTopic.ShortDescription : undefined;
                item.documentation = helpTopic ? {value: helpTopic.LongDescription, kind: ls.MarkupKind.Markdown} : undefined;
                return item;
            });

            return Promise.as(ls.CompletionList.create(options));
        }

        return Promise.as(ls.CompletionList.create([]));
    }

    doRangeFormat(document: ls.TextDocument, range: ls.Range): Promise<ls.TextEdit[]> {
        const text:string = document.getText();
        const rangeStartOffset = document.offsetAt(range.start);
        const rangeEndOffset = document.offsetAt(range.end)
        let textInRange:string = text.substring(rangeStartOffset, rangeEndOffset);

        // if the range includes a trailing newiline (it usually will be if we're highlighting the current command),
        // we don't want to replace that newline, thus we'll reduce the range to not include the trailing newline.
        const newRange = KustoLanguageService.trimTrailingNewlineFromRange(textInRange, rangeStartOffset, document, range);

        const formattedText:string = Kusto.Data.Common.CslQueryParser.PrettifyQuery(textInRange, '');
        return Promise.as([ls.TextEdit.replace(newRange, formattedText)]);
    }

    doDocumentformat(document: ls.TextDocument): Promise<ls.TextEdit[]> {
        const commands = this.getCommandsInDocument(document).then(commands => {
            const formattedCommands = commands.map(command => Kusto.Data.Common.CslQueryParser.PrettifyQuery(command.text, ''));
            const formattedDocument = formattedCommands.join('\r\n\r\n');

            const startPos = document.positionAt(0);
            const endPos = document.positionAt(document.getText().length);
            const fullDocRange = ls.Range.create(startPos, endPos);
            return [ls.TextEdit.replace(fullDocRange, formattedDocument)];
        });

        return commands;
    }

    doCurrentCommandFormat(document: ls.TextDocument, caretPosition: ls.Position): Promise<ls.TextEdit[]> {
        const command: k.CslCommand = this.getCurrentCommand(document, document.offsetAt(caretPosition));
        const start = document.positionAt(command.AbsoluteStart);
        const end = document.positionAt(command.AbsoluteEnd);
        const range = ls.Range.create(start, end);
        return this.doRangeFormat(document, range);
    }

    doFolding(document: ls.TextDocument): Promise<FoldingRange[]> {
        return this.getCommandsInDocument(document).then(commands => {
            return commands.map((command): FoldingRange => {
                // don't count the last empty line as part of the folded range (cnosider linux, mac, pc newlines)
                if (command.text.endsWith("\r\n")) {
                    command.absoluteEnd -= 2;
                } else if (command.text.endsWith("\r") || command.text.endsWith("\n")) {
                    --command.absoluteEnd;
                }

                const startPosition = document.positionAt(command.absoluteStart);

                const endPosition = document.positionAt(command.absoluteEnd);
                return {
                    startLine: startPosition.line,
                    startColumn: startPosition.character,
                    endLine: endPosition.line,
                    endColumn: endPosition.character
                };
            });
        });
    }

    doValidation(document: ls.TextDocument, changeIntervals: {start: number, end: number}[]): Promise<ls.Diagnostic[]> {
        // didn't implement validation for v1.
        if (!this._languageSettings.useIntellisenseV2) {
            return Promise.as([]);
        }

        const script = this.parseDocumentV2(document);
        let blocks = this.toArray<k2.ScriptBlock>(script.Blocks);
        if (changeIntervals.length > 0) {
            blocks = this.getAffectedBlocks(blocks, changeIntervals);
        }

        const diagnostics = blocks.map(block => {

            // Bridge.net bug causes d.ts file to not Generate Diagnostics member, but we know it's there.
            const blockAsAny = block as any;
            if (blockAsAny.Diagnostics && blockAsAny.Diagnostics.Count !== 0) {
                return this.toArray(blockAsAny.Diagnostics) as Kusto.Language.Diagnostic[];
            } else {
                return [];
            }
        }).reduce((prev, curr) => prev.concat(curr), []);

        const lsDiagnostics = this.toLsDiagnostics(diagnostics, document);

        return Promise.as(lsDiagnostics);
    }

     private toLsDiagnostics(diagnostics: Kusto.Language.Diagnostic[], document: ls.TextDocument) {
         return diagnostics.filter(diag => diag.HasLocation).map((diag): ls.Diagnostic => {
             const start = document.positionAt(diag.Start);
             const end = document.positionAt(diag.Start + diag.Length);
             const range = ls.Range.create(start, end);
             return ls.Diagnostic.create(range, diag.Message, ls.DiagnosticSeverity.Error);
         });
     }

    /**
     * Colorize one or more kusto blocks (a.k.a commands), or just the entire document.
     * Supports multi-cursor editing (colorizes blocks on multiple changes).
     * @param document The document to colorize
     * @param changeIntervals an array containing 0 or more changed intervals. if the array is empty - just colorize the entire row.
     * if the array contains a single change - just color the kusto blocks that wraps this change. If multiple changes are provided,
     * colorize all blocks that intersect these changes.
     * The code will try to only parse once if this is the same command.
     */
    doColorization(document: ls.TextDocument, changeIntervals: {start: number, end: number}[]): Promise<ColorizationRange[]> {
        if (!this._languageSettings.useSemanticColorization) {
            return Promise.as([]);
        }

        // V1 intellisense
        if (!this._languageSettings.useIntellisenseV2) {

            // Handle specific ranges changes (and not the whole doc)
            if (changeIntervals.length > 0) {
                this.parseDocumentV1(document, k.ParseMode.CommandTokensOnly);

                const affectedCommands = this.toArray(this._parser.Results).filter(command =>
                    // a command is affected if it intersects at least on of changed ranges.
                    command // command can be null. we're filtering all nulls in the array.
                        ? changeIntervals.some(({start: changeStart, end: changeEnd}) =>
                            // both intervals intersect if either the start or the end of interval A is inside interval B.
                            // If we deleted something at the end of a command, the interval will not intersect the current command.
                            // so we also want consider affected commands commands the end where the interval begins.
                            // hence the + 1.
                            (command.AbsoluteStart >= changeStart && command.AbsoluteStart <= changeEnd)
                            || (changeStart >= command.AbsoluteStart && changeStart <= command.AbsoluteEnd + 1))
                        : false
                );

                // We're not on any command so don't return any classifications.
                // this can happen if we're at the and of the file and deleting empty rows (for example).
                if (!affectedCommands || affectedCommands.length === 0) {
                    return Promise.as([{
                        classifications: [],
                        absoluteStart: changeIntervals[0].start,
                        absoluteEnd: changeIntervals[0].end}]);
                }

                return Promise.as(affectedCommands.map(command => {
                    this.parseTextV1(command.Text, k.ParseMode.TokenizeAllText);
                    const classifications = this.getClassificationsFromParseResult(command.AbsoluteStart);
                    return {
                        classifications,
                        absoluteStart: command.AbsoluteStart,
                        absoluteEnd: command.AbsoluteEnd
                    };
                }));
            }

            // Entire document requested
            this.parseDocumentV1(document, k.ParseMode.TokenizeAllText);
            const classifications = this.getClassificationsFromParseResult();
            return Promise.as([{classifications, absoluteStart: 0, absoluteEnd: document.getText().length}]);
        }

        // V2 intellisense
        const script = this.parseDocumentV2(document);
        if (changeIntervals.length > 0) {

            const blocks = this.toArray<k2.ScriptBlock>(script.Blocks);
            const affectedBlocks = this.getAffectedBlocks(blocks, changeIntervals);

            return Promise.as(affectedBlocks.map(block => ({
                classifications: this.toArray<k2.ClassifiedRange>(block.GetClassifications(block.Start, block.End).Classifications),
                absoluteStart: block.Start,
                absoluteEnd: block.End
            })));
        }

        // Entire document requested
        const blocks = this.toArray<k2.ScriptBlock>(script.Blocks);
        const classifications = blocks.map(block => {
            return this.toArray<k2.ClassifiedRange>(block.GetClassifications(block.Start, block.Length).Classifications);
        }).reduce((prev, curr) => prev.concat(curr), []);

        return Promise.as([{classifications, absoluteStart: 0, absoluteEnd: document.getText().length}]);
    }

     private getAffectedBlocks(blocks: k2.ScriptBlock[], changeIntervals: { start: number; end: number; }[]) {
         return blocks.filter(block =>
             // a command is affected if it intersects at least on of changed ranges.
             block // command can be null. we're filtering all nulls in the array.
                 ? changeIntervals.some(({ start: changeStart, end: changeEnd }) =>
                     // both intervals intersect if either the start or the end of interval A is inside interval B.
                     (block.Start >= changeStart && block.Start <= changeEnd)
                     || (changeStart >= block.Start && changeStart <= block.End + 1))
                 : false);
     }

    setSchema(schema: s.Schema): Promise<void> {
        this._schema = schema;
        if (this._languageSettings.useIntellisenseV2) {
            const kustoJsSchemaV2: GlobalState = schema && schema.clusterType === 'Engine'
                ? this.convertToKustoJsSchemaV2(schema)
                : null;
            this._kustoJsSchemaV2 = kustoJsSchemaV2;
            this._script = undefined;
            this._parsePropertiesV2 = undefined;
        }

        // Since V2 doesn't support control commands, we're initializing V1 intellisense for both cases and we'll going to use V1 intellisense for contorl commands.
        return new Promise((resolve, reject) => {
            const kustoJsSchema = schema
                ? KustoLanguageService.convertToKustoJsSchema(schema)
                : undefined;
            this._kustoJsSchema = kustoJsSchema;
            this.createRulesProvider(kustoJsSchema, schema.clusterType);
            resolve(undefined);
        });
    }

    /**
     * A combination of normalizeSchema and setSchema
     * @param schema schema json as received from .show schema as json
     * @param clusterConnectionString cluster connection string
     * @param databaseInContextName name of database in context
     */
    setSchemaFromShowSchema(schema: s.showSchema.Result, clusterConnectionString: string, databaseInContextName: string): Promise<void> {
            return this.normalizeSchema(schema, clusterConnectionString, databaseInContextName)
                .then(normalized => this.setSchema(normalized));
    }

    /**
     * Converts the result of .show schema as json to a normalized schema used by kusto lagnuage service.
     * @param schema result of show schema
     * @param clusterConnectionString cluster connection string`
     * @param databaseInContextName database in context name
     */
    normalizeSchema(schema: s.showSchema.Result, clusterConnectionString: string, databaseInContextName: string): Promise<s.EngineSchema> {
        const databases: s.EngineSchema["cluster"]["databases"] = Object.keys(schema.Databases).map(key => schema.Databases[key]).map(({Name, Tables, Functions, MinorVersion, MajorVersion}: s.showSchema.Database)  => ({
            name: Name,
            minorVersion: MinorVersion,
            majorVersion: MajorVersion,
            tables: Object.keys(Tables).map(key => Tables[key]).map(({Name, OrderedColumns}: s.showSchema.Table) => ({
                name: Name,
                columns: OrderedColumns.map(({Name, Type, CslType}: s.showSchema.Column) => ({
                    name: Name,
                    type: CslType,
                }))
            })),
            functions: Object.keys(Functions).map(key => Functions[key]).map(({Name, Body, InputParameters}) => ({
                name: Name,
                body: Body,
                inputParameters: InputParameters.map(inputParam => ({
                    name: inputParam.Name,
                    type: inputParam.Type,
                    cslType: inputParam.CslType,
                    columns: inputParam.Columns ? inputParam.Columns.map(col => ({name: col.Name, type: col.Type, cslType: col.CslType})) : []
                }))
            }))
        }));

        const result: s.EngineSchema = {
            clusterType: 'Engine',
            cluster: {
                connectionString: clusterConnectionString,
                databases: databases
            },
            database: databases.filter(db => db.name === databaseInContextName)[0]
        }

        return Promise.as(result);
    }

    getSchema() {
        return Promise.as(this._schema);
    }

    getCommandInContext(document: ls.TextDocument, cursorOffset: number): Promise<string | null> {
        return this._languageSettings.useIntellisenseV2
            ? this.getCommandInContextV2(document, cursorOffset)
            : this.getCommandInContextV1(document, cursorOffset);
    }

    getCommandInContextV1(document: ls.TextDocument, cursorOffset: number): Promise<string | null> {
        this.parseDocumentV1(document, k.ParseMode.CommandTokensOnly);
        const command = this.getCurrentCommand(document, cursorOffset);
        if (!command) {
            return Promise.as( null);
        }

        return Promise.as(command.Text)
    }

    getCommandInContextV2(document: ls.TextDocument, cursorOffset: number): Promise<string | null> {
        const script = this.parseDocumentV2(document);
        const block = this.getCurrentCommandV2(script, cursorOffset);
        if (!block) {
            return Promise.as(null);
        }

        // TODO: do we need to do tricks like V1 is doing in this.getCurrentCommand?
        return Promise.as(block.Text);
    }

    /**
     * Retrun an array of commands in document. each command contains the range and text.
     */
    getCommandsInDocument(document: ls.TextDocument): Promise<{absoluteStart: number, absoluteEnd: number, text: string}[]> {
        return this._languageSettings.useIntellisenseV2
            ? this.getCommandsInDocumentV2(document)
            : this.getCommandsInDocumentV1(document);
    }

    getCommandsInDocumentV1(document: ls.TextDocument): Promise<{absoluteStart: number, absoluteEnd: number, text: string}[]> {
        this.parseDocumentV1(document, k.ParseMode.CommandTokensOnly);
        let commands = this.toArray(this._parser.Results);
        return Promise.as(commands.map(({AbsoluteStart, AbsoluteEnd, Text}) => ({absoluteStart:AbsoluteStart, absoluteEnd: AbsoluteEnd, text: Text})));
    }

    getCommandsInDocumentV2(document: ls.TextDocument): Promise<{absoluteStart: number, absoluteEnd: number, text: string}[]> {
        const script = this.parseDocumentV2(document);
        let commands = this.toArray<k2.ScriptBlock>(script.Blocks);
        return Promise.as(commands.map(({Start, End, Text}) => ({absoluteStart:Start, absoluteEnd: End, text: Text})));
    }

    getClientDirective(text: string): Promise<{isClientDirective: boolean, directiveWithoutLeadingComments: string}> {
        let outParam: { v: string | null } = { v: null };
        const isClientDirective =  k.CslCommandParser.IsClientDirective(text, outParam);
        return Promise.as({
            isClientDirective,
            directiveWithoutLeadingComments: outParam.v
        });
    }

    getAdminCommand(text: string): Promise<{isAdminCommand: boolean, adminCommandWithoutLeadingComments: string}> {
        let outParam : {v: string | null } = {v: null };
        const isAdminCommand = k.CslCommandParser.IsAdminCommand$1(text, outParam);
        return Promise.as({
            isAdminCommand,
            adminCommandWithoutLeadingComments: outParam.v
        })
    }

    //#region dummy schema for manual testing
    static get dummySchema() {
        const database: Database = {
            majorVersion: 0,
            minorVersion: 0,
            name: 'Kuskus',
            tables: [{
                name: 'KustoLogs',
                columns: [{
                  name: 'Source',
                  type: 'string'
                }, {
                    name: 'Timestamp',
                    type: 'datetime'
                }, {
                    name: 'Directory',
                    type: 'string'
                }]
            }],
            functions: [{
                name: 'HowBig',
                inputParameters: [{
                    name: 'T',
                    columns: [{
                        name: 'Timestamp',
                        type: 'System.DateTime',
                        cslType: 'datetime'
                    }]
                }],
                body: "{\r\n    union \r\n    (T | count | project V='Volume', Metric = strcat(Count/1e9, ' Billion records')),\r\n    (T | summarize FirstRecord=min(Timestamp)| project V='Volume', Metric = strcat(toint((now()-FirstRecord)/1d), ' Days of data (from: ', format_datetime(FirstRecord, 'yyyy-MM-dd'),')')),\r\n    (T | where Timestamp > ago(1h) | count | project V='Velocity', Metric = strcat(Count/1e6, ' Million records / hour')),\r\n    (T | summarize Latency=now()-max(Timestamp) | project V='Velocity', Metric = strcat(Latency / 1sec, ' seconds latency')),\r\n    (T | take 1 | project V='Variety', Metric=tostring(pack_all()))\r\n    | order by V \r\n}"
            }, {
                name: 'FindCIDPast24h',
                inputParameters: [{
                    name: 'clientActivityId',
                    type: 'System.String',
                    cslType: 'string'
                }],
                body: "{ KustoLogs | where Timestamp > now(-1d) | where ClientActivityId == clientActivityId}   "
            }]
        };

        const languageServiceSchema : s.EngineSchema = {
            clusterType: 'Engine',
            cluster: {
                connectionString: 'https://kuskus.kusto.windows.net;fed=true',
                databases: [database]
            },
            database: database
        }

        return languageServiceSchema;
    }
    //#endregion

    private static convertToEntityDataType(kustoType: string) {

    }
    /**
     * We do not want to expose Bridge.Net generated schema, so we expose a cleaner javascript schema.
     * Here it gets converted to the bridge.Net schema
     * @param schema Language Service schema
     */
    private static convertToKustoJsSchema(schema: s.Schema): k.KustoIntelliSenseQuerySchema | CmSchema | undefined {
        switch (schema.clusterType) {
            case 'Engine':
                const currentDatabaseName = schema.database ? schema.database.name : undefined;
                const kCluster = new k.KustoIntelliSenseClusterEntity();
                let kDatabaseInContext: k.KustoIntelliSenseDatabaseEntity = undefined;

                kCluster.ConnectionString = schema.cluster.connectionString;
                const databases = [];
                schema.cluster.databases.forEach(database => {
                    const kDatabase = new k.KustoIntelliSenseDatabaseEntity();
                    kDatabase.Name = database.name;
                    const tables = [];
                    database.tables.forEach(table => {
                        const kTable = new k.KustoIntelliSenseTableEntity();
                        kTable.Name = table.name;
                        const cols = [];
                        table.columns.forEach(column => {
                            const kColumn = new k.KustoIntelliSenseColumnEntity();
                            kColumn.Name = column.name;
                            kColumn.TypeCode = k.EntityDataType[getEntityDataTypeFromCslType(column.type)];
                            cols.push(kColumn);
                        });
                        kTable.Columns = new Bridge.ArrayEnumerable(cols);
                        tables.push(kTable);
                    });
                    const functions = [];
                    database.functions.forEach(fn => {
                        const kFunction = new k.KustoIntelliSenseFunctionEntity();
                        kFunction.Name = fn.name,
                        kFunction.CallName = s.getCallName(fn),
                        kFunction.Expression = s.getExpression(fn),
                        functions.push(kFunction);
                    });

                    kDatabase.Tables = new Bridge.ArrayEnumerable(tables);
                    kDatabase.Functions = new Bridge.ArrayEnumerable(functions);
                    databases.push(kDatabase);

                    if (database.name == currentDatabaseName) {
                        kDatabaseInContext = kDatabase;
                    }
                });
                kCluster.Databases = new Bridge.ArrayEnumerable(databases);
                const kSchema  = new k.KustoIntelliSenseQuerySchema(kCluster, kDatabaseInContext);
                return kSchema;
            case 'ClusterManager':
                const accounts = schema.accounts.map(account => {
                    const kAccount = new k.KustoIntelliSenseAccountEntity();
                    kAccount.Name = account;
                    return kAccount;
                });

                const services = schema.services.map(service => {
                    const kService = new k.KustoIntelliSenseServiceEntity();
                    kService.Name = service;
                    return kService;
                });

                const connectionString = schema.connectionString;

                const result: CmSchema = {
                    accounts,
                    services,
                    connectionString
                }
                return result;
            case "DataManagement":
                return undefined;
            default:
                return assertNever(schema);
        }
    }

        /**
     * Returns something like '(x: string, y: datetime)'
     * @param params scalar parameters
     */
    private static scalarParametersToSignature(params: s.ScalarParameter[]) {
        const signatureWithoutParens = params.map(param => `${param.name}: ${param.cslType}`).join(', ');
        return `(${signatureWithoutParens})`;
    }

    /**
     * Returns something like '(x: string, T: (y: int))'
     * @param params input parameters (tabular or scalar)
     */
    private static inputParameterToSignature(params: s.InputParameter[]) {
        const signatureWithoutParens = params.map(param => {
            if (param.columns) {
                const tableSignature = this.scalarParametersToSignature(param.columns);
                return `${param.name}: ${tableSignature}`;
            } else {
                return `${param.name}: ${param.cslType}`;
            }
        }).join(', ');
        return `(${signatureWithoutParens})`;
    }

    /**
     * converts a function definition to a let statement.
     * @param fn function
     */
    private static toLetStatement(fn: s.Function): string {
        const signature = this.inputParameterToSignature(fn.inputParameters);
        return `let ${fn.name} = ${signature} ${fn.body}`
    }

    private static convertToDatabaseSymbol(db: s.Database, globalState: GlobalState, addFunctions: boolean): sym.DatabaseSymbol {
        const createColumnSymbol: (col: s.ScalarParameter) => sym.ColumnSymbol = col =>
            new sym.ColumnSymbol(col.name, sym.ScalarTypes.GetSymbol(getCslTypeNameFromClrType(col.type)));


        const createParameterSymbol: (param: s.InputParameter) => sym.Parameter  = param =>  {
            if (!param.columns) {
                const paramSymbol = Kusto.Language.Symbols.ScalarTypes.GetSymbol(getCslTypeNameFromClrType(param.type));
                return new sym.Parameter.$ctor2(param.name, paramSymbol);
            }

            if (param.columns.length == 0) {
                return new sym.Parameter.ctor(
                    param.name,
                    sym.ParameterTypeKind.Tabular,
                    sym.ArgumentKind.Expression,
                    null,
                    null,
                    false,
                    null,
                    1,
                    1);
            }

            const argumentType = new sym.TableSymbol.ctor(param.columns.map(col => createColumnSymbol(col)))
            return new sym.Parameter.$ctor2(param.name, argumentType);
        }

        const createFunctionSymbol: (fn: s.Function) => sym.FunctionSymbol = fn => {
            var parameters = fn.inputParameters.map(param => createParameterSymbol(param));

            // TODO: handle outputColumns (right now it doesn't seem to be implemented for any function).
            return new sym.FunctionSymbol.$ctor16(fn.name, fn.body, parameters);
        }


        const createTableSymbol: (tbl: s.Table) => sym.TableSymbol = tbl => {
            const columnSymbols = tbl.columns.map(col => createColumnSymbol(col));
            return new sym.TableSymbol.$ctor3(tbl.name, columnSymbols);
        }

        const createDatabaseSymbol: (db: s.Database) => sym.DatabaseSymbol = db => {
            const tableSymbols: sym.Symbol[] = db.tables.map(tbl => createTableSymbol(tbl));
            const functionSymbols = db.functions.map(fun => createFunctionSymbol(fun));
            return new sym.DatabaseSymbol.ctor(db.name, tableSymbols.concat(functionSymbols));
        }

        const databaseSymbol = createDatabaseSymbol(db);

        return databaseSymbol;
    }

    private convertToKustoJsSchemaV2(schema: s.EngineSchema): GlobalState {
        let  cached = this._schemaCache[schema.cluster.connectionString];

        // create a cache entry for the cluster if non yet exists.
        if (!cached) {
            this._schemaCache[schema.cluster.connectionString] = {};
            cached = this._schemaCache[schema.cluster.connectionString];
        }

        // Remove deleted databases from cache
        const schemaDbLookup: {[dbName: string]: s.Database} = schema.cluster.databases.reduce((prev, curr) => prev[curr.name] = curr, {});
        Object.keys(cached).map(dbName => {
            if (!schemaDbLookup[dbName]) {
                delete cached.dbName;
            }
        });

        let globalState = GlobalState.Default;
        const currentDatabaseName = schema.database ? schema.database.name : undefined;

        let databaseInContext: sym.DatabaseSymbol | undefined = undefined;

        // Update out-of-data databses to cache
        const databases = schema.cluster.databases.map(db => {
            const shouldIncludeFunctions = db.name === currentDatabaseName;

            const cachedDb = cached[db.name];
            // This is an older version than we have, or we need to parse functions.
            if (!cachedDb || cachedDb.database.majorVersion < db.majorVersion || (shouldIncludeFunctions && !cachedDb.includesFunctions)) {
                // only add functions for the database in context (it's very time consuming)

                const databaseSymbol = KustoLanguageService.convertToDatabaseSymbol(db, globalState, shouldIncludeFunctions);
                cached[db.name] = {database: db, symbol: databaseSymbol, includesFunctions: shouldIncludeFunctions};
            }

            const databaseSymbol = cached[db.name].symbol;
            if (db.name === currentDatabaseName) {
                databaseInContext = databaseSymbol;
            }

            return databaseSymbol;
        });

        const hostname = new URL(schema.cluster.connectionString.split(';')[0]).hostname;
        const clusterName = hostname.split('.')[0];
        const clusterSymbol = new sym.ClusterSymbol.ctor(clusterName, databases);



        globalState = globalState.WithCluster(clusterSymbol)

        if (databaseInContext) {
            globalState = globalState.WithDatabase(databaseInContext);
        }

        return globalState;
    }

    private getClassificationsFromParseResult(offset: number = 0) {
        const classifications = this.toArray(this._parser.Results)
        .map(command => this.toArray(command.Tokens))
       .reduce((prev, curr) => prev.concat(curr), [])
       .map((cslCommandToken): k2.ClassifiedRange => {
            const range = new k2.ClassifiedRange();
            range.Kind = this.tokenKindToClassificationKind(cslCommandToken.TokenKind)
            range.Start = cslCommandToken.AbsoluteStart + offset;
            range.Length = cslCommandToken.Length;

            return range;
       });

       return classifications;
    }

     /**
     * trim trailing newlines from range
     */
    private static trimTrailingNewlineFromRange(textInRange: string, rangeStartOffset: number, document: ls.TextDocument, range: ls.Range) {
        let currentIndex = textInRange.length - 1;
        while (textInRange[currentIndex] === '\r' || textInRange[currentIndex] === '\n') {
            --currentIndex;
        }
        const newEndOffset = rangeStartOffset + currentIndex + 1;
        const newEndPosition = document.positionAt(newEndOffset);
        const newRange = ls.Range.create(range.start, newEndPosition);
        return newRange;
    }

    /**
     * Maps numbers to strings, such that if a>b numerically, f(a)>f(b) lexicograhically.
     * 1 -> "a", 26 -> "z", 27 -> "za", 28 -> "zb", 52 -> "zz", 53 ->"zza"
     * @param order - The number to be converted to a sorting-string. order should start at 1.
     * @returns A string repenting the order.
     */
    private getSortText(order: number):string {
        if (order <= 0 ) {
            throw new RangeError(`order should be a number >= 1. instead got ${order}`);
        }

        let sortText = "";
        let numCharacters = 26; // "z" - "a" + 1;

        let div = Math.floor(order / numCharacters);

        for (let i = 0; i < div; ++i) {
            sortText += "z";
        }

        let reminder = order % numCharacters;

        if (reminder > 0) {
            sortText += String.fromCharCode(96 + reminder);
        }

        return sortText;
    }

    /**
     * ParseTextV1 parses the given text with the given parse mode.
     * Additionally - it will make sure not to provide rules provider for non-engine clusters
     * since the only rules provider parse can handle is the engine's. It will try to look for function
     * definitions to colorize and will throw since they're not there.
     * @param text
     * @param parseMode
     */
    private parseTextV1(text: string, parseMode: k.ParseMode) {
        this._parser.Parse(
            this._schema.clusterType === 'Engine'
                    ? this._rulesProvider as any
                    : null,
                text,
                parseMode);
    }

    private parseDocumentV1(document: ls.TextDocument, parseMode: k.ParseMode) {
        // already parsed a later version, or better parse mode for this uri
        if (this._parsePropertiesV1 && !this._parsePropertiesV1.isParseNeeded(document, this._rulesProvider, parseMode)) {
            return;
        }

        this.parseTextV1(document.getText(), parseMode);

        this._parsePropertiesV1 = new ParseProperties(document.version, document.uri, this._rulesProvider, parseMode);
    }

    private parseDocumentV2(document: ls.TextDocument) {
        if (this._parsePropertiesV2 && !this._parsePropertiesV2.isParseNeeded(document, this._rulesProvider)) {
            return this._script;
        }

        if (!this._script) {
            this._script = k2.Script.From(document.getText(), this._kustoJsSchemaV2);
        } else {
            this._script = this._script.WithText(document.getText());
        }


        this._parsePropertiesV2 = new ParseProperties(document.version, document.uri);

        return this._script;
    }

    /**
     * Return the CslCommand that wraps the caret location, or undefined if caret is outside any command
     * @param document the document to extract the current command from
     * @param caretAbsolutePosition absolute caret position
     */
    private getCurrentCommand(document: ls.TextDocument, caretAbsolutePosition: number): k.CslCommand | undefined {
        let commands = this.toArray(this._parser.Results);

        let command = commands.filter(command => command.AbsoluteStart <= caretAbsolutePosition && command.AbsoluteEnd >= caretAbsolutePosition)[0];

        // There is an edge case when cursor appears at the end of the command
        // which is not yet considered to be part of the parsed command (therefore: +1 for the AbsoluteEdit property)
        if (!command) {
            command = commands.filter(command => command.AbsoluteStart <= caretAbsolutePosition && command.AbsoluteEnd + 1 >= caretAbsolutePosition)[0];

            // If we have 2 newlines in the end of the text the cursor is _probably_ at the end of the text
            // which this means that we're not actually standing on any command. Thus return null.
            if (!command || command.Text.endsWith('\r\n\r\n')) {
                return null;
            }
        }

        return command;
    }

    private getCurrentCommandV2(script: k2.Script, offset: number) {
        let block = script.GetBlockAtPosition(offset);

        return block;
    }

    private getTextToInsert(rule: k.IntelliSenseRule, option: k.CompletionOption): {insertText: string, insertTextFormat: ls.InsertTextFormat} {
        const beforeApplyInfo = rule.GetBeforeApplyInfo(option.Value);
        const afterApplyInfo = rule.GetAfterApplyInfo(option.Value);

        // this is the basic text to be insterted,
        // but we still need to figure out where the cursor will end up after completion is applied.
        let insertText = beforeApplyInfo.Text || '' + option.Value + afterApplyInfo.Text || '';
        let insertTextFormat: ls.InsertTextFormat = ls.InsertTextFormat.PlainText;

        const snippetFinalTabStop = '\$0';
        if (afterApplyInfo.OffsetToken && afterApplyInfo.OffsetPosition) {
            const tokenOffset = insertText.indexOf(afterApplyInfo.OffsetToken);
            if (tokenOffset >= 0) {
                insertText = this.insertToString(insertText, snippetFinalTabStop, tokenOffset - insertText.length + afterApplyInfo.OffsetPosition);
                insertTextFormat = ls.InsertTextFormat.Snippet
            }
        } else if (afterApplyInfo.OffsetPosition) { // We only handle negative offsets
            insertText = this.insertToString(insertText, snippetFinalTabStop, afterApplyInfo.OffsetPosition);
            insertTextFormat = ls.InsertTextFormat.Snippet;
        }

        return {insertText, insertTextFormat};
    }

    /**
     * create a new string with stringToInsert inserted at offsetFromEnd in originalString.
     * @param originalString string to insert to
     * @param stringToInsert string to insert
     * @param offsetFromEnd a negative number that will represent offset to the left. 0 means simple concat
     */
    private insertToString(originalString:string, stringToInsert:string, offsetFromEnd: number): string {
        var index = originalString.length + offsetFromEnd;

        if (offsetFromEnd >= 0 || index < 0) {
            return originalString;  // Cannot insert before or after the string
        }

        var before = originalString.substring(0, index);
        var after = originalString.substring(index);

        return before + stringToInsert + after;
    }

    private getCommandWithoutLastWord(text: string): string {
        const lastWordRegex = XRegExp('[\\w_]*$', 's');
        return text.replace(lastWordRegex, '');
    }

    private createRulesProvider(schema: k.KustoIntelliSenseQuerySchema | CmSchema |  undefined, clusterType: s.ClusterType) {
        var queryParameters: any = new (List(String))();
        var availableClusters: any = new (List(String))();
        this._parser = new k.CslCommandParser();

        if (clusterType == 'Engine') {
            const engineSchema = schema as k.KustoIntelliSenseQuerySchema;
            this._rulesProvider = this._languageSettings && this._languageSettings.includeControlCommands
                ? new k.CslIntelliSenseRulesProvider.$ctor1(engineSchema.Cluster, engineSchema, queryParameters, availableClusters, null, true, true)
                : new k.CslQueryIntelliSenseRulesProvider.$ctor1(engineSchema.Cluster, engineSchema, queryParameters, availableClusters, null, null, null);
            return;
        }

        if (clusterType === 'DataManagement') {
            this._rulesProvider = new k.DataManagerIntelliSenseRulesProvider(null);
            return;
        }

        // This is a cluster manger
        const { accounts, services, connectionString } = schema as CmSchema
        new k.KustoIntelliSenseAccountEntity
        new k.KustoIntelliSenseServiceEntity
        this._rulesProvider = new k.ClusterManagerIntelliSenseRulesProvider.$ctor1(
            new Bridge.ArrayEnumerable(accounts),
            new Bridge.ArrayEnumerable(services),
            connectionString);
    }

    private _kustoKindtolsKind = {
        [k.OptionKind.None]: ls.CompletionItemKind.Interface,
        [k.OptionKind.Operator]: ls.CompletionItemKind.Method,
        [k.OptionKind.Command]: ls.CompletionItemKind.Method,
        [k.OptionKind.Service]: ls.CompletionItemKind.Class,
        [k.OptionKind.Policy]: ls.CompletionItemKind.Reference,
        [k.OptionKind.Database]: ls.CompletionItemKind.Class,
        [k.OptionKind.Table]: ls.CompletionItemKind.Class,
        [k.OptionKind.DataType]: ls.CompletionItemKind.Class,
        [k.OptionKind.Literal]: ls.CompletionItemKind.Property,
        [k.OptionKind.Parameter]: ls.CompletionItemKind.Variable,
        [k.OptionKind.IngestionMapping]: ls.CompletionItemKind.Variable,
        [k.OptionKind.ExpressionFunction]: ls.CompletionItemKind.Variable,
        [k.OptionKind.Option]: ls.CompletionItemKind.Interface,
        [k.OptionKind.OptionKind]: ls.CompletionItemKind.Interface,
        [k.OptionKind.OptionRender]: ls.CompletionItemKind.Interface,
        [k.OptionKind.Column]: ls.CompletionItemKind.Function,
        [k.OptionKind.ColumnString]: ls.CompletionItemKind.Field,
        [k.OptionKind.ColumnNumeric]: ls.CompletionItemKind.Field,
        [k.OptionKind.ColumnDateTime]: ls.CompletionItemKind.Field,
        [k.OptionKind.ColumnTimespan]: ls.CompletionItemKind.Field,
        [k.OptionKind.FunctionServerSide]:ls.CompletionItemKind.Field,
        [k.OptionKind.FunctionAggregation]: ls.CompletionItemKind.Field,
        [k.OptionKind.FunctionFilter]: ls.CompletionItemKind.Field,
        [k.OptionKind.FunctionScalar]: ls.CompletionItemKind.Field,
        [k.OptionKind.ClientDirective]: ls.CompletionItemKind.Enum
    }

    private _kustoKindtolsKindV2: {[k in k2.CompletionKind]: ls.CompletionItemKind} = {
        [k2.CompletionKind.AggregateFunction]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.ClausePrefix]: ls.CompletionItemKind.Interface,
        [k2.CompletionKind.Cluster]: ls.CompletionItemKind.Class,
        [k2.CompletionKind.Column]: ls.CompletionItemKind.Function,
        [k2.CompletionKind.Database]: ls.CompletionItemKind.Class,
        [k2.CompletionKind.Identifier]: ls.CompletionItemKind.Method,
        [k2.CompletionKind.Keyword]: ls.CompletionItemKind.Method,
        [k2.CompletionKind.Literal]: ls.CompletionItemKind.Property,
        [k2.CompletionKind.Parameter]: ls.CompletionItemKind.Variable,
        [k2.CompletionKind.Punctuation] :ls.CompletionItemKind.Interface,
        [k2.CompletionKind.QueryPrefix]: ls.CompletionItemKind.Function,
        [k2.CompletionKind.RenderChart]: ls.CompletionItemKind.Method,
        [k2.CompletionKind.ScalarFunction]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.ScalarInfix]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.ScalarPrefix]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.Syntax]: ls.CompletionItemKind.Method,
        [k2.CompletionKind.Table]: ls.CompletionItemKind.Class,
        [k2.CompletionKind.TabularFunction]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.TabularPrefix]: ls.CompletionItemKind.Field,
        // datatable, externaldata
        [k2.CompletionKind.TabularSuffix]: ls.CompletionItemKind.Field,
        [k2.CompletionKind.Unknown] : ls.CompletionItemKind.Interface,
        [k2.CompletionKind.Variable]: ls.CompletionItemKind.Variable,
    }

    private kustoKindToLsKind(kustoKind: k.OptionKind): ls.CompletionItemKind {
        let res = this._kustoKindtolsKind[kustoKind];
        return res ? res : ls.CompletionItemKind.Variable;
    }

    private kustoKindToLsKindV2(kustoKind: k2.CompletionKind): ls.CompletionItemKind {
        let res = this._kustoKindtolsKindV2[kustoKind];
        return res ? res : ls.CompletionItemKind.Variable;
    }

    private toArray<T>(bridgeList: System.Collections.Generic.IEnumerable$1<T>): T[] {
        return (Bridge as any).toArray(bridgeList);
    }

    private _tokenKindToClassificationKind: {[k in TokenKind]: k2.ClassificationKind} = {
        [TokenKind.TableToken] : k2.ClassificationKind.Table,
        [TokenKind.TableColumnToken]: k2.ClassificationKind.Column,
        [TokenKind.OperatorToken]: k2.ClassificationKind.QueryOperator,
        [TokenKind.SubOperatorToken]: k2.ClassificationKind.Function,
        [TokenKind.CalculatedColumnToken]: k2.ClassificationKind.Column,
        [TokenKind.StringLiteralToken]: k2.ClassificationKind.Literal,
        [TokenKind.FunctionNameToken]: k2.ClassificationKind.Function,
        [TokenKind.UnknownToken]: k2.ClassificationKind.PlainText,
        [TokenKind.CommentToken]: k2.ClassificationKind.Comment,
        [TokenKind.PlainTextToken]: k2.ClassificationKind.PlainText,
        [TokenKind.DataTypeToken]: k2.ClassificationKind.Type,
        [TokenKind.ControlCommandToken]: k2.ClassificationKind.PlainText, // TODO ?
        [TokenKind.CommandPartToken]: k2.ClassificationKind.PlainText, // TODO ?
        [TokenKind.QueryParametersToken]: k2.ClassificationKind.QueryParameter,
        [TokenKind.CslCommandToken]: k2.ClassificationKind.Keyword, // TODO ?
        [TokenKind.LetVariablesToken]: k2.ClassificationKind.Identifier, // TODO ?
        [TokenKind.PluginToken]: k2.ClassificationKind.Function,
        [TokenKind.BracketRangeToken]: k2.ClassificationKind.Keyword, // TODO ?
        [TokenKind.ClientDirectiveToken]: k2.ClassificationKind.Keyword // TODO ?
    }
    private tokenKindToClassificationKind(token: TokenKind): k2.ClassificationKind {
        const conversion = this._tokenKindToClassificationKind[token];
        return conversion || k2.ClassificationKind.PlainText;
    }
}

let languageService = new KustoLanguageService(
    KustoLanguageService.dummySchema,
    {includeControlCommands: true, useIntellisenseV2: false, useSemanticColorization: true});

/**
 * Obtain an instance of the kusto language service.
 */
export function getKustoLanguageService(): LanguageService {
    return languageService;
}
